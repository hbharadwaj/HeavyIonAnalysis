// To run 
// combine({"../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_nom_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_nom_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_ABCD_purity_JER_nom_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_ABCD_purity_JER_nom_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JEC_up_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JEC_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JEC_down_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JEC_down_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_up_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_down_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_down_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_nom_response_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_JER_nom_response_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_Substructure_up_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_Substructure_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_cent_up_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_cent_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_cent_down_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_cent_down_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_RefParton_updatedMC_angu_bin_2/OutputUnfolded_Data_0_30_Jan_26_QCDPhoton_RefParton_updatedMC_angu_bin_2.root"},{"nom","ABCD","JECup","JECdown","JERup","JERdown","response","Substructure_up","Centup","Centdown","Pythia_qg","Data_0_30_Jan_26_angu_updatedMC_bin_2"},"Data_0_30_Jan_26_angu_updatedMC_bin_2.root","OutputCombined/","unfold_X",8,12)
// combine({"../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_nom_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_nom_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_ABCD_purity_JER_nom_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_ABCD_purity_JER_nom_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JEC_up_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JEC_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JEC_down_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JEC_down_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_up_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_down_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_down_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_nom_response_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_JER_nom_response_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_Substructure_up_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_Substructure_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_cent_up_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_cent_up_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_cent_no_shift_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_cent_no_shift_updatedMC_angu_bin_2.root","../Unfolded_Plots/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_RefParton_updatedMC_angu_bin_2/OutputUnfolded_Data_30_90_Jan_26_QCDPhoton_RefParton_updatedMC_angu_bin_2.root"},{"nom","ABCD","JECup","JECdown","JERup","JERdown","response","Substructure_up","Centup","Centdown","Pythia_qg","Data_30_90_Jan_26_angu_updatedMC_bin_2"},"Data_30_90_Jan_26_angu_updatedMC_bin_2.root","OutputCombined/","unfold_X",7,8)
// combine(,{"nom","ABCD","JERup","JERdown","JECup","JECdown","Centup","Centdown","Substructure_up","Substructure_down","AltMC","response"},6,13)
// plot_combine("OutputCombined/Data_0_30_Dec_07_angu_xJ_gp4_l3_bin_2.root","Data_0_30_Dec_07_angu_xJ_gp4_l3_bin_2") 
//---------------------------

#include <iostream>         // needed for I/O


const float min_cent_val = 0;
const float max_cent_val = 30;
TString label="May_29_pp_2017_sys_xJ_gp8"+TString("_Data");
TString varname = "Rg";
TString output_path = "OutputCombined/";
TCanvas c;
TLegend *l1;

void Plot_hist(std::vector<TH1D*>,std::vector<TString> ,TString opt="label",std::vector<TString> eopt={"end"});
void Plot_hist_up(std::vector<TH1D*>,std::vector<TString> ,TString opt="label",std::vector<TString> eopt={"end"});
void Plot_hist_down(std::vector<TH1D*>,std::vector<TString> ,TString opt="label",std::vector<TString> eopt={"end"});
void Plot_hist_err(std::vector<TH1D*>,std::vector<TGraphAsymmErrors*>,std::vector<TString> ,TString opt="label",std::vector<TString> eopt={"end"});
void overlay(std::vector<TH1D*>,std::vector<TString> ,TString opt="label",std::vector<TString> eopt={"end"});


void combine(TString in_varname="",int iter_ref = 6,int iter_prior = 13,TString out_filename="",TString out_filepath="", TString hname="unfold_X"){
    
    std::vector<TString> file_list  = {"Pythia8_nom","ABCD_purity","JER_up","JER_down","JEC_up","JEC_down","Cent_up","Cent_down","PFScale_up","PFScale_down","AltMC","response"};
    std::vector<TString> label_list = {"nom","ABCD","JERup","JERdown","JECup","JECdown","Centup","Centdown","Substructure_up","Substructure_down","AltMC","response"};
    if(in_varname!="")
        varname=in_varname;
    if(out_filepath!="")
        output_path=out_filepath;
    
    TString output_filename = Form("Data_%.0f_%.0f_%s_%s_%s",min_cent_val,max_cent_val,label.Data(),varname.Data(),hname.Data());
    if(out_filename==""){
        out_filename=output_filename;
        if(label_list.size()!=(file_list.size())){
            printf("Run with \n root -l\n .L plot_combine.cc \n pp_combine({<path_to_files>},{<labels>,out_hname},out_filepath,hname)\n");
            printf("\n <labels> = 'nom','ABCD','JECup','JECdown','JERup','JERdown','response','Substructure_up','Substructure_down','Centup','Centdown'\n");
            return;
        }
        std::cout<<"Label Not Provided\n";        
        std::cout<<"Label Set to -> \t"<<output_filename<<"\n";        
        label_list.push_back(output_filename);
    }
    if(label_list.size()!=(file_list.size()+1)){
        printf("Run with \n root -l\n .L plot_combine.cc \n pp_combine({<path_to_files>},{<labels>,out_hname},out_filepath,hname)\n");
        printf("\n <labels> = 'nom','ABCD','JECup','JECdown','JERup','JERdown','response','Substructure_up','Substructure_down','Centup','Centdown','Pythia_qg'\n");
        return;
    }
    
    TString DIR = output_path +"/";
    TString makedir = "mkdir -p " + DIR;
    const char *mkDIR = makedir.Data();
    gSystem->Exec(mkDIR);
    
    TFile *f_out = new TFile(output_path+"/"+out_filename+".root", "recreate");
    TDirectory *target = gDirectory;
    std::vector<TH1D*> hist_input;
    std::vector<TString> histname_input;
    for(int i=0;i<file_list.size();i++){
        TString filepath = Form("../Unfolded_Plots/OutputUnfolded_%.0f_%.0f_%s/OutputUnfolded_%.0f_%.0f_%s_%s_%s.root",min_cent_val,max_cent_val,label.Data(),min_cent_val,max_cent_val,label.Data(),file_list[i].Data(),varname.Data());
        TFile *f = TFile::Open(filepath);
        TH1D* htemp = (TH1D*)f->Get(Form("%s",hname.Data()));
        target->cd();
        htemp->Write(label_list.back()+"_"+label_list[i],TObject::kWriteDelete);
        hist_input.push_back((TH1D*)htemp->Clone());
        histname_input.push_back(label_list[i]);
        if(label_list[i].Contains("nom")){
            int iter_m1 = iter_ref -1;
            TH1D* htemp_m1 = (TH1D*)f->Get(Form("Bayesian/%s%d",hname.Data(),iter_prior));
            target->cd();
            htemp_m1->Write(label_list.back()+"_unfoldm1",TObject::kWriteDelete);
            hist_input.push_back((TH1D*)htemp_m1->Clone());
            histname_input.push_back("Regularization");

            int iter_p1 = iter_ref +1;
            TH1D* htemp_p1 = (TH1D*)f->Get(Form("Bayesian/%s%d",hname.Data(),iter_prior));
            target->cd();
            htemp_p1->Write(label_list.back()+"_unfoldp1",TObject::kWriteDelete);
            // hist_input.push_back((TH1D*)htemp_p1->Clone());
            // histname_input.push_back("unfoldp1");
        }
        delete f;
    }
    histname_input.push_back(label_list.back());

    label+="_"+varname;

    std::vector<TString>sel = {Form("p_{T}^{#gamma}>%.0f, x_{J}>%.2f, Anti-#it{k}_{T} #it{R}=0.2",160.0,0.25),"  ","Bayes Unfolded","z_{cut}=0.2"};   
    overlay(hist_input,histname_input,"right",sel);
    /*
    std::vector<TH1D*> hist_input_ratio;
    std::vector<TString> histname_input_ratio;
    for(int i =0; i<hist_input.size()-1;i++){
        hist_input_ratio.push_back((TH1D*)hist_input[i+1]->Clone());
        hist_input_ratio[i]->Add(hist_input[0],-1);
        hist_input_ratio[i]->Divide(hist_input[0]);
        histname_input_ratio.push_back((TString)histname_input[i+1]);
    }
    histname_input_ratio.push_back(label_list.back()+"rel_uncert"); 
    sel.push_back("nostackhist][P0");
    Plot_hist(hist_input_ratio,histname_input_ratio,"right_opt",sel);*/
    f_out->Close();
}

void plot_combine(TString hname,TString file="", TString label_in="", TString out_path=""){
    label = hname;
    if(label_in!="")
        label=label_in;
    if(out_path!="")
        output_path=out_path; //+ "Outputcombined_"+label+"/";
    if(file=="")
        file=output_path+hname+".root";

    // gROOT->SetBatch();
    gErrorIgnoreLevel = kFatal;
    TString DIR = output_path;
    TString makedir = "mkdir -p " + DIR;
    const char *mkDIR = makedir.Data();
    gSystem->Exec(mkDIR);

    TFile *f = TFile::Open(file,"Update");

    TH1D *herr_nom = (TH1D*)f->Get(hname+"_nom");
    TH1D *herr_unfoldm1 = (TH1D*)f->Get(hname+"_unfoldm1");
    TH1D *herr_unfoldp1 = (TH1D*)f->Get(hname+"_unfoldp1");
    TH1D *herr_purity_up = (TH1D*)f->Get(hname+"_ABCD");
    TH1D *herr_purity_down = (TH1D*)f->Get(hname+"_ABCD");
    TH1D *herr_JECup = (TH1D*)f->Get(hname+"_JECup");
    TH1D *herr_JECdown = (TH1D*)f->Get(hname+"_JECdown");
    TH1D *herr_JERup = (TH1D*)f->Get(hname+"_JERup");
    TH1D *herr_JERdown = (TH1D*)f->Get(hname+"_JERdown");
    TH1D *herr_response_up = (TH1D*)f->Get(hname+"_response");
    TH1D *herr_response_down = (TH1D*)f->Get(hname+"_response");
    TH1D *herr_Substructure_up = (TH1D*)f->Get(hname+"_Substructure_up");
    TH1D *herr_Substructure_down = (TH1D*)f->Get(hname+"_Substructure_down");
    TH1D *herr_Centup = (TH1D*)f->Get(hname+"_Centup");
    TH1D *herr_Centdown = (TH1D*)f->Get(hname+"_Centdown");
    TH1D *herr_Pythia_prior_up = (TH1D*)f->Get(hname+"_AltMC");
    TH1D *herr_Pythia_prior_down = (TH1D*)f->Get(hname+"_AltMC");

    TH1D *herr_total_up = (TH1D*)herr_nom->Clone("herr_total");
    TH1D *herr_total_down = (TH1D*)herr_nom->Clone("herr_total");

    // herr_nom->SetTitle("Nominal");
    // herr_unfoldm1->SetTitle("Regularization Bias");
    // herr_unfoldp1->SetTitle("Regularization Bias (sym)");
    // herr_purity_up->SetTitle("#gamma Purity");
    // herr_purity_down->SetTitle("#gamma Purity (sym)");
    // herr_JECup->SetTitle("JEC up");
    // herr_JECdown->SetTitle("JEC down");
    // herr_JERup->SetTitle("JER up");
    // herr_JERdown->SetTitle("JER down");
    // herr_response_up->SetTitle("Response Matrix stats");
    // herr_response_down->SetTitle("Response Matrix stats (sym)");
    // herr_Substructure_up->SetTitle("Substructure up");
    // herr_Substructure_down->SetTitle("Substructure down");
    // herr_Centup->SetTitle("Centrality up");
    // herr_Centdown->SetTitle("Centrality down");
    // herr_Pythia_prior_up->SetTitle("MC Modeling");
    // herr_Pythia_prior_down->SetTitle("MC Modeling (sym)");

    // herr_total_up->SetTitle("Total sys. up");
    // herr_total_down->SetTitle("Total sys. down");

    herr_nom->SetTitle("Nominal");
    herr_unfoldm1->SetTitle("Regularization Bias");
    herr_unfoldp1->SetTitle("Regularization Bias (sym)");
    herr_purity_up->SetTitle("Photon purity");
    herr_purity_down->SetTitle("Photon purity (sym)");
    herr_JECup->SetTitle("Jet energy scale up");
    herr_JECdown->SetTitle("Jet energy scale");
    herr_JERup->SetTitle("Jet energy resolution up");
    herr_JERdown->SetTitle("Jet energy resolution");
    herr_response_up->SetTitle("Response matrix stats");
    herr_response_down->SetTitle("Response matrix stats");
    herr_Substructure_up->SetTitle("PF energy scale up");
    herr_Substructure_down->SetTitle("PF energy scale");
    herr_Centup->SetTitle("Centrality up");
    herr_Centdown->SetTitle("Centrality");
    herr_Pythia_prior_up->SetTitle("Fragmentation model");
    herr_Pythia_prior_down->SetTitle("Fragmentation model (sym)");

    herr_total_up->SetTitle("Total syst. up");
    herr_total_down->SetTitle("Total Correlated PF syst.");

 
    // Input Histograms 
        TH1D *hnom = (TH1D*)f->Get(hname+"_nom");
        TH1D *hunfoldm1 = (TH1D*)f->Get(hname+"_unfoldm1");
        TH1D *hunfoldp1 = (TH1D*)f->Get(hname+"_unfoldp1");
        TH1D *hpurity = (TH1D*)f->Get(hname+"_ABCD");
        TH1D *hJECup = (TH1D*)f->Get(hname+"_JECup");
        TH1D *hJECdown = (TH1D*)f->Get(hname+"_JECdown");
        TH1D *hJERup = (TH1D*)f->Get(hname+"_JERup");
        TH1D *hJERdown = (TH1D*)f->Get(hname+"_JERdown");
        TH1D *hresponse = (TH1D*)f->Get(hname+"_response");
        TH1D *hSubstructure_up = (TH1D*)f->Get(hname+"_Substructure_up");
        TH1D *hSubstructure_down = (TH1D*)f->Get(hname+"_Substructure_down");
        TH1D *hCentup = (TH1D*)f->Get(hname+"_Centup");
        TH1D *hCentdown = (TH1D*)f->Get(hname+"_Centdown");
        TH1D *hPythia_qg = (TH1D*)f->Get(hname+"_AltMC");// (TH1D*)f->Get(hname+"_nom");
        TH1D *hPythia_gg = (TH1D*)f->Get(hname+"_AltMC");// (TH1D*)f->Get(hname+"_nom");

        std::vector<TH1D*> hinput;  
        // Build a vector of input histograms 
        // 0 -> nominal 
        // 1 -> Regularization iter_prior
        // 2 -> Regularization iter_prior
        // 3 -> Photon Purity -> ABCD
        // 4 -> JEC up
        // 5 -> JEC down
        // 6 -> JER up
        // 7 -> JER down
        // 8 -> Response matrix Stats
        // 9 -> Substructure up
        //10 -> Substructure down
        //11 -> Cent up
        //12 -> Cent down
        //13 -> MC Modelling - q/g Modified
        //14 -> MC Modelling - q/g Modified

        hinput.push_back((TH1D*)hnom->Clone("Nominal"));
        hinput.push_back((TH1D*)hunfoldm1->Clone("Unfoldm1"));
        hinput.push_back((TH1D*)hunfoldp1->Clone("Unfoldp1"));
        hinput.push_back((TH1D*)hpurity->Clone("ABCD_purity"));
        hinput.push_back((TH1D*)hJECup->Clone("JECup"));
        hinput.push_back((TH1D*)hJECdown->Clone("JECdown"));
        hinput.push_back((TH1D*)hJERup->Clone("JERup"));
        hinput.push_back((TH1D*)hJERdown->Clone("JERdown"));
        hinput.push_back((TH1D*)hresponse->Clone("response"));
        hinput.push_back((TH1D*)hSubstructure_up->Clone("Substructure_up"));
        hinput.push_back((TH1D*)hSubstructure_down->Clone("Substructure_down"));
        hinput.push_back((TH1D*)hCentup->Clone("Centup"));
        hinput.push_back((TH1D*)hCentdown->Clone("Centdown"));
        hinput.push_back((TH1D*)hPythia_qg->Clone("Pythia-q_g modfied"));
        hinput.push_back((TH1D*)hPythia_gg->Clone("Pythia-q_g modfied"));

    Double_t vec_x[20],vec_y[20],vec_y_one[20],errx_do[20],errx_up[20],erry_do[20],erry_up[20],errstat_do[20],errstat_up[20],errtot_do[20],errtot_up[20];
    for(Int_t j=0;j<=hinput[0]->GetNbinsX()+2;j++){ 
        //Statistical
            Double_t erry_stat_a = 9999;
            // if(hinput[0]->GetBinContent(j)!=0)
                erry_stat_a=hinput[0]->GetBinError(j);
            Double_t erry_stat_b=erry_stat_a;

        // Regularization
            Double_t erryitermenos=-1*hinput[0]->GetBinContent(j)+hinput[1]->GetBinContent(j); 
            Double_t erryiter=-1*hinput[0]->GetBinContent(j)+hinput[2]->GetBinContent(j); 
            Double_t erry_reg_a=-1, erry_reg_b=-1;

            if(erryiter>0 && erryitermenos>0){ 
                erry_reg_a=max(erryiter,erryitermenos);
                erry_reg_b=0;
            }
            if(erryiter<0 && erryitermenos<0){
                erry_reg_a=0;
                erry_reg_b=-1*min(erryiter,erryitermenos);
            }
            if(erryiter>0 && erryitermenos<0){
                erry_reg_a=erryiter;
                erry_reg_b=-1*erryitermenos;
            }
            if(erryiter<0 && erryitermenos>0){
                erry_reg_a=erryitermenos;
                erry_reg_b=-1*erryiter;
            }

            erry_reg_a = fabs(erryiter);
            erry_reg_b = erry_reg_a;

        // Photon Purity -> Symmetrized
            Double_t erry_purity_a = fabs(-1*hinput[0]->GetBinContent(j)+hinput[3]->GetBinContent(j));   
            Double_t erry_purity_b = erry_purity_a;

        // JEC
            Double_t erry_JEC_a = fabs(-1*hinput[0]->GetBinContent(j)+hinput[4]->GetBinContent(j));   
            Double_t erry_JEC_b = fabs(-1*hinput[0]->GetBinContent(j)+hinput[5]->GetBinContent(j));
        // JER
            Double_t erry_JER_a = fabs(-1*hinput[0]->GetBinContent(j)+hinput[6]->GetBinContent(j));   
            Double_t erry_JER_b = fabs(-1*hinput[0]->GetBinContent(j)+hinput[7]->GetBinContent(j));
        
        // Response Matrix Stats
            Double_t erry_response_a = fabs(hinput[8]->GetBinError(j));   
            Double_t erry_response_b = erry_response_a;

        // Substructure
            Double_t erry_substructure_a = fabs(-1*hinput[0]->GetBinContent(j)+hinput[9]->GetBinContent(j));   
            Double_t erry_substructure_b = fabs(-1*hinput[0]->GetBinContent(j)+hinput[10]->GetBinContent(j));
        
        // Centrality
            Double_t erry_cent_a = fabs(-1*hinput[0]->GetBinContent(j)+hinput[11]->GetBinContent(j));   
            Double_t erry_cent_b = fabs(-1*hinput[0]->GetBinContent(j)+hinput[12]->GetBinContent(j));

        // Pythia q/g Prior

            // Double_t erry_Pythia_prior_a = fabs(hinput[9]->GetBinContent(j)-hinput[10]->GetBinContent(j));
            // Double_t erry_Pythia_prior_b = erry_Pythia_prior_a;
            Double_t erry_Pythia_prior_a = fabs(hinput[13]->GetBinContent(j)-hinput[0]->GetBinContent(j));   // q/g Modified
            Double_t erry_Pythia_prior_b = fabs(hinput[14]->GetBinContent(j)-hinput[0]->GetBinContent(j));  // q/g Modified

        Double_t erry_uncorr_up = TMath::Sqrt(erry_substructure_a*erry_substructure_a); //TMath::Sqrt(erry_reg_a*erry_reg_a + erry_purity_a*erry_purity_a + erry_JEC_a*erry_JEC_a + erry_JER_a*erry_JER_a + erry_response_a*erry_response_a + erry_substructure_a*erry_substructure_a + erry_cent_a*erry_cent_a + erry_Pythia_prior_a*erry_Pythia_prior_a); // 
        Double_t erry_uncorr_do = TMath::Sqrt(erry_substructure_b*erry_substructure_b); //TMath::Sqrt(erry_reg_b*erry_reg_b + erry_purity_b*erry_purity_b + erry_JEC_b*erry_JEC_b + erry_JER_b*erry_JER_b + erry_response_b*erry_response_b + erry_substructure_b*erry_substructure_b + erry_cent_b*erry_cent_b + erry_Pythia_prior_b*erry_Pythia_prior_b); //  

        Double_t toterr_up = TMath::Sqrt(erry_stat_a*erry_stat_a + erry_uncorr_up*erry_uncorr_up);
        Double_t toterr_do = TMath::Sqrt(erry_stat_b*erry_stat_b + erry_uncorr_do*erry_uncorr_do);

        float den_val= hinput[0]->GetBinContent(j);
        if(den_val==0) den_val=999999999;
        herr_nom->SetBinContent(j,0);
        herr_unfoldm1->SetBinContent(j,0);
        herr_unfoldp1->SetBinContent(j,0);
        // herr_nom->SetBinContent(j,erry_stat_a/(den_val));
        // herr_unfoldm1->SetBinContent(j,erry_reg_a/den_val);
        // herr_unfoldp1->SetBinContent(j,-erry_reg_b/den_val);
        herr_purity_up->SetBinContent(j,erry_purity_a/den_val);
        herr_purity_down->SetBinContent(j,-erry_purity_b/den_val);
        herr_JECup->SetBinContent(j,erry_JEC_a/den_val);
        herr_JECdown->SetBinContent(j,-erry_JEC_b/den_val);
        herr_JERup->SetBinContent(j,erry_JER_a/den_val);
        herr_JERdown->SetBinContent(j,-erry_JER_b/den_val);
        herr_response_up->SetBinContent(j,erry_response_a/den_val);
        herr_response_down->SetBinContent(j,-erry_response_b/den_val);
        herr_Substructure_up->SetBinContent(j,erry_substructure_a/den_val);
        herr_Substructure_down->SetBinContent(j,-erry_substructure_b/den_val);
        herr_Centup->SetBinContent(j,erry_cent_a/den_val);
        herr_Centdown->SetBinContent(j,-erry_cent_b/den_val);
        herr_Pythia_prior_up->SetBinContent(j,erry_Pythia_prior_a/(den_val));
        herr_Pythia_prior_down->SetBinContent(j,-erry_Pythia_prior_b/(den_val));
        herr_total_up->SetBinContent(j,erry_uncorr_up/den_val);
        herr_total_down->SetBinContent(j,-erry_uncorr_do/den_val);

        // Error x and vectors

        vec_x[j] = hinput[0]->GetBinCenter(j);
        vec_y[j] = hinput[0]->GetBinContent(j);
        vec_y_one[j] = 1;

        errstat_up[j] = erry_stat_a;
        errstat_do[j] = erry_stat_b;      
        errx_do[j] = 0.5*hinput[0]->GetBinWidth(j);
        errx_up[j] = errx_do[j];
        erry_up[j] = erry_uncorr_up;
        erry_do[j] = erry_uncorr_do;
        errtot_up[j] = toterr_up;
        errtot_do[j] = toterr_do;
    }

    auto stat_uncert = new TGraphAsymmErrors(hinput[0]->GetNbinsX()+2,vec_x,vec_y,errx_up,errx_do,errstat_up,errstat_do);
    auto sys_uncert = new TGraphAsymmErrors(hinput[0]->GetNbinsX()+2,vec_x,vec_y,errx_up,errx_do,erry_up,erry_do);
    auto tot_uncert = new TGraphAsymmErrors(hinput[0]->GetNbinsX()+2,vec_x,vec_y,errx_up,errx_do,errtot_up,errtot_do);

    herr_nom->Write("herr_nom_output",TObject::kWriteDelete);
    herr_unfoldm1->Write("herr_unfoldm1_output",TObject::kWriteDelete);
    herr_unfoldp1->Write("herr_unfoldp1_output",TObject::kWriteDelete);
    herr_purity_up->Write("herr_purity_output",TObject::kWriteDelete);
    herr_JECup->Write("herr_JECup_output",TObject::kWriteDelete);
    herr_JECdown->Write("herr_JECdown_output",TObject::kWriteDelete);
    herr_JERup->Write("herr_JERup_output",TObject::kWriteDelete);
    herr_JERdown->Write("herr_JERdown_output",TObject::kWriteDelete);
    herr_response_up->Write("herr_response_output",TObject::kWriteDelete);
    herr_Substructure_up->Write("herr_Substructure_up_output",TObject::kWriteDelete);
    herr_Substructure_down->Write("herr_Substructure_down_output",TObject::kWriteDelete);
    herr_Centup->Write("herr_Centup_output",TObject::kWriteDelete);
    herr_Centdown->Write("herr_Centdown_output",TObject::kWriteDelete);
    herr_Pythia_prior_up->Write("herr_Pythia_qg_output",TObject::kWriteDelete);
    herr_total_up->Write("herr_total_up_output",TObject::kWriteDelete);
    herr_total_down->Write("herr_total_down_output",TObject::kWriteDelete);
    stat_uncert->Write("stat_uncert",TObject::kWriteDelete);
    sys_uncert->Write("sys_uncert",TObject::kWriteDelete);
    tot_uncert->Write("tot_uncert",TObject::kWriteDelete);

    std::vector<TString>sel = {" ","#bf{PbPb 1.7 nb^{-1}(5.02 TeV)}","Cent. 0-30%",Form("p_{T}^{#gamma}>%.0f, x_{J}>%.1f,|#Delta #phi_{#gamma,jet}|>#frac{2}{3}#pi",100.0,0.8)}; 
    if(label.Contains("Rg")){
        hinput[0]->SetMinimum(0.0);
        hinput[0]->SetMaximum(12.0);
        // Plot_hist_err({hinput[0]},{sys_uncert},{"sys. uncert","R_{g}","1/N_{jet} dN/dR_{g}",label+"_combined"},"right_label",sel);
    }
    else{
        hinput[0]->SetMinimum(0.0);
        hinput[0]->SetMaximum(24.0);
        // Plot_hist_err({hinput[0]},{sys_uncert},{"sys. uncert","#it{g}","1/N_{jet} dN/d#it{g}",label+"_combined"},"right_label",sel);
    }

    // std::vector<TH1D*> hist_input_ratio;
    // std::vector<TString> histname_input_ratio;
    // hist_input_ratio.push_back((TH1D*)herr_nom->Clone());
    // herr_nom->Scale(-1.0);
    // hist_input_ratio.push_back((TH1D*)herr_nom->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_unfoldm1->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_unfoldp1->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_purity_up->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_purity_down->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_JECup->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_JECdown->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_JERup->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_JERdown->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_response_up->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_response_down->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_Substructure_up->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_Substructure_down->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_Centup->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_Centdown->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_Pythia_prior_up->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_Pythia_prior_down->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_total_up->Clone());
    // hist_input_ratio.push_back((TH1D*)herr_total_down->Clone());

    // histname_input_ratio.push_back("Stat. unc");
    // histname_input_ratio.push_back("Stat. unc (sym)");
    // histname_input_ratio.push_back(herr_unfoldm1->GetTitle());
    // histname_input_ratio.push_back(herr_unfoldp1->GetTitle());
    // histname_input_ratio.push_back(herr_purity_up->GetTitle());
    // histname_input_ratio.push_back(herr_purity_down->GetTitle());
    // histname_input_ratio.push_back(herr_JECup->GetTitle());
    // histname_input_ratio.push_back(herr_JECdown->GetTitle());
    // histname_input_ratio.push_back(herr_JERup->GetTitle());
    // histname_input_ratio.push_back(herr_JERdown->GetTitle());
    // histname_input_ratio.push_back(herr_response_up->GetTitle());
    // histname_input_ratio.push_back(herr_response_down->GetTitle());
    // histname_input_ratio.push_back(herr_Substructure_up->GetTitle());
    // histname_input_ratio.push_back(herr_Substructure_down->GetTitle());
    // histname_input_ratio.push_back(herr_Centup->GetTitle());
    // histname_input_ratio.push_back(herr_Centdown->GetTitle());
    // histname_input_ratio.push_back(herr_Pythia_prior_up->GetTitle());
    // histname_input_ratio.push_back(herr_Pythia_prior_down->GetTitle());
    // histname_input_ratio.push_back(herr_total_up->GetTitle());
    // histname_input_ratio.push_back(herr_total_down->GetTitle());
    // if(label.Contains("Rg")){
    //     histname_input_ratio.push_back("R_{g}");
    // }
    // else{
    //     histname_input_ratio.push_back("#it{g}");
    // }
    // histname_input_ratio.push_back("Rel. uncertainties");
    // histname_input_ratio.push_back(label+"_rel_uncert");

    // sel.push_back("end");
    // sel.push_back("NOSTACKB_HIST");
    // if(label.Contains("Rg")){
    //     Plot_hist(hist_input_ratio,histname_input_ratio,"left_opt_label",sel);
    // }
    // else{
    //     Plot_hist(hist_input_ratio,histname_input_ratio,"left_opt_label",sel); // Maybe change to Center?
    // }

    //* Splitting Up and Down Variations 

        // std::vector<TH1D*> hist_input_ratio_up;
        // std::vector<TString> histname_input_ratio_up;
        // hist_input_ratio_up.push_back((TH1D*)herr_nom->Clone());
        // // herr_nom->Scale(-1.0);
        // // hist_input_ratio_up.push_back((TH1D*)herr_nom->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_unfoldm1->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_unfoldp1->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_purity_up->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_purity_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_JECup->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_JECdown->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_JERup->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_JERdown->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_response_up->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_response_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Substructure_up->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_Substructure_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Centup->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_Centdown->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Pythia_prior_up->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_Pythia_prior_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_total_up->Clone());
        // // hist_input_ratio_up.push_back((TH1D*)herr_total_down->Clone());

        // histname_input_ratio_up.push_back("Stat. unc");
        // // histname_input_ratio_up.push_back("Stat. Unc (sym)");
        // histname_input_ratio_up.push_back(herr_unfoldm1->GetTitle());
        // // histname_input_ratio_up.push_back(herr_unfoldp1->GetTitle());
        // histname_input_ratio_up.push_back(herr_purity_up->GetTitle());
        // // histname_input_ratio_up.push_back(herr_purity_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_JECup->GetTitle());
        // // histname_input_ratio_up.push_back(herr_JECdown->GetTitle());
        // histname_input_ratio_up.push_back(herr_JERup->GetTitle());
        // // histname_input_ratio_up.push_back(herr_JERdown->GetTitle());
        // histname_input_ratio_up.push_back(herr_response_up->GetTitle());
        // // histname_input_ratio_up.push_back(herr_response_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_Substructure_up->GetTitle());
        // // histname_input_ratio_up.push_back(herr_Substructure_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_Centup->GetTitle());
        // // histname_input_ratio_up.push_back(herr_Centdown->GetTitle());
        // histname_input_ratio_up.push_back(herr_Pythia_prior_up->GetTitle());
        // // histname_input_ratio_up.push_back(herr_Pythia_prior_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_total_up->GetTitle());
        // // histname_input_ratio_up.push_back(herr_total_down->GetTitle());

        // //* DOWN ------------------------------------------------

        // std::vector<TH1D*> hist_input_ratio_down;
        // std::vector<TString> histname_input_ratio_down;
        // // hist_input_ratio_down.push_back((TH1D*)herr_nom->Clone());
        // herr_nom->Scale(-1.0);
        // hist_input_ratio_down.push_back((TH1D*)herr_nom->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_unfoldm1->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_unfoldp1->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_purity_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_purity_down->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_JECup->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_JECdown->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_JERup->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_JERdown->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_response_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_response_down->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_Substructure_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Substructure_down->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_Centup->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Centdown->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_Pythia_prior_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Pythia_prior_down->Clone());
        // // hist_input_ratio_down.push_back((TH1D*)herr_total_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_total_down->Clone());

        // // histname_input_ratio_down.push_back("Stat. Unc");
        // histname_input_ratio_down.push_back("Stat. unc");
        // // histname_input_ratio_down.push_back(herr_unfoldm1->GetTitle());
        // histname_input_ratio_down.push_back(herr_unfoldp1->GetTitle());
        // // histname_input_ratio_down.push_back(herr_purity_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_purity_down->GetTitle());
        // // histname_input_ratio_down.push_back(herr_JECup->GetTitle());
        // histname_input_ratio_down.push_back(herr_JECdown->GetTitle());
        // // histname_input_ratio_down.push_back(herr_JERup->GetTitle());
        // histname_input_ratio_down.push_back(herr_JERdown->GetTitle());
        // // histname_input_ratio_down.push_back(herr_response_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_response_down->GetTitle());
        // // histname_input_ratio_down.push_back(herr_Substructure_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_Substructure_down->GetTitle());
        // // histname_input_ratio_down.push_back(herr_Centup->GetTitle());
        // histname_input_ratio_down.push_back(herr_Centdown->GetTitle());
        // // histname_input_ratio_down.push_back(herr_Pythia_prior_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_Pythia_prior_down->GetTitle());
        // // histname_input_ratio_down.push_back(herr_total_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_total_down->GetTitle());

    //* Splitting Up and Down Variations 

        std::vector<TH1D*> hist_input_ratio_up;
        std::vector<TString> histname_input_ratio_up;

        // herr_nom->Scale(-1.0);
        hist_input_ratio_up.push_back((TH1D*)herr_nom->Clone());
        hist_input_ratio_up.push_back((TH1D*)herr_unfoldm1->Clone());
        hist_input_ratio_up.push_back((TH1D*)herr_unfoldp1->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_purity_up->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_purity_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_JECup->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_JECdown->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_JERup->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_JERdown->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_response_up->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_response_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Substructure_up->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Substructure_down->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Centup->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Centdown->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Pythia_prior_up->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_Pythia_prior_down->Clone());
        hist_input_ratio_up.push_back((TH1D*)herr_total_up->Clone());
        // hist_input_ratio_up.push_back((TH1D*)herr_total_down->Clone());

        histname_input_ratio_up.push_back("");
        histname_input_ratio_up.push_back("");
        histname_input_ratio_up.push_back("");
        // histname_input_ratio_up.push_back("Stat. unc");
        // histname_input_ratio_up.push_back("Stat. Unc (sym)");
        // histname_input_ratio_up.push_back(herr_unfoldm1->GetTitle());
        // histname_input_ratio_up.push_back(herr_unfoldp1->GetTitle());
        // histname_input_ratio_up.push_back(herr_purity_up->GetTitle());
        // histname_input_ratio_up.push_back(herr_purity_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_JECup->GetTitle());
        // histname_input_ratio_up.push_back(herr_JECdown->GetTitle());
        // histname_input_ratio_up.push_back(herr_JERup->GetTitle());
        // histname_input_ratio_up.push_back(herr_JERdown->GetTitle());
        // histname_input_ratio_up.push_back(herr_response_up->GetTitle());
        // histname_input_ratio_up.push_back(herr_response_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_Substructure_up->GetTitle());
        // histname_input_ratio_up.push_back(herr_Substructure_down->GetTitle());
        // histname_input_ratio_up.push_back(herr_Centup->GetTitle());
        // histname_input_ratio_up.push_back(herr_Centdown->GetTitle());
        // histname_input_ratio_up.push_back(herr_Pythia_prior_up->GetTitle());
        // histname_input_ratio_up.push_back(herr_Pythia_prior_down->GetTitle());
        histname_input_ratio_up.push_back(herr_total_up->GetTitle());
        // histname_input_ratio_up.push_back(herr_total_down->GetTitle());

        //* DOWN ------------------------------------------------

        std::vector<TH1D*> hist_input_ratio_down;
        std::vector<TString> histname_input_ratio_down;
        // hist_input_ratio_down.push_back((TH1D*)herr_nom->Clone());
        // herr_nom->Scale(-1.0);
        hist_input_ratio_down.push_back((TH1D*)herr_nom->Clone());
        hist_input_ratio_down.push_back((TH1D*)herr_unfoldm1->Clone());
        hist_input_ratio_down.push_back((TH1D*)herr_unfoldp1->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_purity_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_purity_down->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_JECup->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_JECdown->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_JERup->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_JERdown->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_response_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_response_down->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Substructure_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Substructure_down->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Centup->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Centdown->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Pythia_prior_up->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_Pythia_prior_down->Clone());
        // hist_input_ratio_down.push_back((TH1D*)herr_total_up->Clone());
        hist_input_ratio_down.push_back((TH1D*)herr_total_down->Clone());

        histname_input_ratio_down.push_back(" ");
        histname_input_ratio_down.push_back(" ");
        histname_input_ratio_down.push_back(" ");
        // histname_input_ratio_down.push_back("Stat. Unc");
        // histname_input_ratio_down.push_back("Stat. unc");
        // histname_input_ratio_down.push_back(herr_unfoldm1->GetTitle());
        // histname_input_ratio_down.push_back(herr_unfoldp1->GetTitle());
        // histname_input_ratio_down.push_back(herr_purity_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_purity_down->GetTitle());
        // histname_input_ratio_down.push_back(herr_JECup->GetTitle());
        // histname_input_ratio_down.push_back(herr_JECdown->GetTitle());
        // histname_input_ratio_down.push_back(herr_JERup->GetTitle());
        // histname_input_ratio_down.push_back(herr_JERdown->GetTitle());
        // histname_input_ratio_down.push_back(herr_response_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_response_down->GetTitle());
        // histname_input_ratio_down.push_back(herr_Substructure_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_Substructure_down->GetTitle());
        // histname_input_ratio_down.push_back(herr_Centup->GetTitle());
        // histname_input_ratio_down.push_back(herr_Centdown->GetTitle());
        // histname_input_ratio_down.push_back(herr_Pythia_prior_up->GetTitle());
        // histname_input_ratio_down.push_back(herr_Pythia_prior_down->GetTitle());
        // histname_input_ratio_down.push_back(herr_total_up->GetTitle());
        histname_input_ratio_down.push_back(herr_total_down->GetTitle());

        
    if(label.Contains("Rg")){
        histname_input_ratio_up.push_back("R_{g}");
        histname_input_ratio_down.push_back("R_{g}");
    }
    else{
        histname_input_ratio_up.push_back("#it{g}");
        histname_input_ratio_down.push_back("#it{g}");
    }
    histname_input_ratio_up.push_back("Rel. uncertainties");
    histname_input_ratio_up.push_back(label+"_rel_uncert");

    histname_input_ratio_down.push_back("Rel. uncertainties");
    histname_input_ratio_down.push_back(label+"_rel_uncert");

    sel.push_back("end");
    sel.push_back("NOSTACKB_HIST");
    if(label.Contains("Rg")){

        Plot_hist_up(hist_input_ratio_up,histname_input_ratio_up,"left_opt_label_leg",sel);
        sel.pop_back();
        sel.push_back("NOSTACKB_HIST_SAME");
        Plot_hist_down(hist_input_ratio_down,histname_input_ratio_down,"left_opt_label",sel);
    }
    else{
        Plot_hist_up(hist_input_ratio_up,histname_input_ratio_up,"left_opt_label_leg",sel); 
        sel.pop_back();
        sel.push_back("NOSTACKB_HIST_SAME");
        Plot_hist_down(hist_input_ratio_down,histname_input_ratio_down,"left_opt_label",sel); 
    }

    f->Close();
}

// void print_sys(TString file){
//     TFile *f = TFile::Open(file);

//     TH1D *herr_nom = (TH1D*)f->Get("herr_nom_output");
//     TH1D *herr_unfoldm1 = (TH1D*)f->Get("herr_unfoldm1_output");
//     TH1D *herr_unfoldp1 = (TH1D*)f->Get("herr_unfoldp1_output");
//     TH1D *herr_purity_up = (TH1D*)f->Get("herr_purity_output");
//     TH1D *herr_JECup = (TH1D*)f->Get("herr_JECup_output");
//     TH1D *herr_JECdown = (TH1D*)f->Get("herr_JECdown_output");
//     TH1D *herr_JERup = (TH1D*)f->Get("herr_JERup_output");
//     TH1D *herr_JERdown = (TH1D*)f->Get("herr_JERdown_output");
//     TH1D *herr_response_up = (TH1D*)f->Get("herr_response_output");
//     TH1D *herr_Centup = (TH1D*)f->Get("herr_Centup_output");
//     TH1D *herr_Centdown = (TH1D*)f->Get("herr_Centdown_output");
//     TH1D *herr_Pythia_prior_up = (TH1D*)f->Get("herr_Pythia_qg_output");
//     TH1D *herr_total_up = (TH1D*)f->Get("herr_total_up_output");
//     TH1D *herr_total_down = (TH1D*)f->Get("herr_total_down_output");
    
//     double herr_nom_val=-999;
//     double herr_unfoldm1_val=-999;
//     double herr_unfoldp1_val=-999;
//     double herr_purity_up_val=-999;
//     double herr_JECup_val=-999;
//     double herr_JECdown_val=-999;
//     double herr_JERup_val=-999;
//     double herr_JERdown_val=-999;
//     double herr_response_up_val=-999;
//     double herr_Centup_val=-999;
//     double herr_Centdown_val=-999;
//     double herr_Pythia_prior_up_val=-999;
//     double herr_total_up_val=-999;
//     double herr_total_down_val=-999;

//     double herr_nom_min_max[2]={9999,-9999};
//     double herr_unfoldm1_min_max[2]={9999,-9999};
//     double herr_unfoldp1_min_max[2]={9999,-9999};
//     double herr_purity_up_min_max[2]={9999,-9999};
//     double herr_JECup_min_max[2]={9999,-9999};
//     double herr_JECdown_min_max[2]={9999,-9999};
//     double herr_JERup_min_max[2]={9999,-9999};
//     double herr_JERdown_min_max[2]={9999,-9999};
//     double herr_response_up_min_max[2]={9999,-9999};
//     double herr_Centup_min_max[2]={9999,-9999};
//     double herr_Centdown_min_max[2]={9999,-9999};
//     double herr_Pythia_prior_up_min_max[2]={9999,-9999};
//     double herr_total_up_min_max[2]={9999,-9999};
//     double herr_total_down_min_max[2]={9999,-9999};
    

//     std::cout<<"|Bin |Stat| Regularization | Purity | JEC up | JEC down | JER up | JER down | Response | Centrality up | Centrality down | MC Modelling | Total up| Total down|\n";
//     std::cout<<"|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n";
//     for(int i=1;i<herr_nom->GetNbinsX();i++){
//         herr_nom_val=fabs(herr_nom->GetBinContent(i)*100.0);
//         herr_unfoldm1_val=fabs(herr_unfoldm1->GetBinContent(i)*100.0);
//         herr_unfoldp1_val=fabs(herr_unfoldp1->GetBinContent(i)*100.0);
//         herr_purity_up_val=fabs(herr_purity_up->GetBinContent(i)*100.0);
//         herr_JECup_val=fabs(herr_JECup->GetBinContent(i)*100.0);
//         herr_JECdown_val=fabs(herr_JECdown->GetBinContent(i)*100.0);
//         herr_JERup_val=fabs(herr_JERup->GetBinContent(i)*100.0);
//         herr_JERdown_val=fabs(herr_JERdown->GetBinContent(i)*100.0);
//         herr_response_up_val=fabs(herr_response_up->GetBinContent(i)*100.0);
//         herr_Centup_val=fabs(herr_Centup->GetBinContent(i)*100.0);
//         herr_Centdown_val=fabs(herr_Centdown->GetBinContent(i)*100.0);
//         herr_Pythia_prior_up_val=fabs(herr_Pythia_prior_up->GetBinContent(i)*100.0);
//         herr_total_up_val=fabs(herr_total_up->GetBinContent(i)*100.0);
//         herr_total_down_val=fabs(herr_total_down->GetBinContent(i)*100.0);

//         printf("|%*d|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|%.1f|\n",2,i,
//         herr_nom_val,
//         herr_unfoldp1_val,
//         herr_purity_up_val,
//         herr_JECup_val,
//         herr_JECdown_val,
//         herr_JERup_val,
//         herr_JERdown_val,
//         herr_response_up_val,
//         herr_Centup_val,
//         herr_Centdown_val,
//         herr_Pythia_prior_up_val,
//         herr_total_up_val,
//         herr_total_down_val);

//         if(herr_nom_val<herr_nom_min_max[0]) herr_nom_min_max[0] = herr_nom_val;
//         if(herr_unfoldp1_val<herr_unfoldp1_min_max[0]) herr_unfoldp1_min_max[0] = herr_unfoldp1_val;
//         if(herr_purity_up_val<herr_purity_up_min_max[0]) herr_purity_up_min_max[0] = herr_purity_up_val;
//         if(herr_JECup_val<herr_JECup_min_max[0]) herr_JECup_min_max[0] = herr_JECup_val;
//         if(herr_JECdown_val<herr_JECdown_min_max[0]) herr_JECdown_min_max[0] = herr_JECdown_val;
//         if(herr_JERup_val<herr_JERup_min_max[0]) herr_JERup_min_max[0] = herr_JERup_val;
//         if(herr_JERdown_val<herr_JERdown_min_max[0]) herr_JERdown_min_max[0] = herr_JERdown_val;
//         if(herr_response_up_val<herr_response_up_min_max[0]) herr_response_up_min_max[0] = herr_response_up_val;
//         if(herr_Centup_val<herr_Centup_min_max[0]) herr_Centup_min_max[0] = herr_Centup_val;
//         if(herr_Centdown_val<herr_Centdown_min_max[0]) herr_Centdown_min_max[0] = herr_Centdown_val;
//         if(herr_Pythia_prior_up_val<herr_Pythia_prior_up_min_max[0]) herr_Pythia_prior_up_min_max[0] = herr_Pythia_prior_up_val;
//         if(herr_total_up_val<herr_total_up_min_max[0]) herr_total_up_min_max[0] = herr_total_up_val;
//         if(herr_total_down_val<herr_total_down_min_max[0]) herr_total_down_min_max[0] = herr_total_down_val;

//         if(herr_nom_val>herr_nom_min_max[1]) herr_nom_min_max[1] = herr_nom_val;
//         if(herr_unfoldp1_val>herr_unfoldp1_min_max[1]) herr_unfoldp1_min_max[1] = herr_unfoldp1_val;
//         if(herr_purity_up_val>herr_purity_up_min_max[1]) herr_purity_up_min_max[1] = herr_purity_up_val;
//         if(herr_JECup_val>herr_JECup_min_max[1]) herr_JECup_min_max[1] = herr_JECup_val;
//         if(herr_JECdown_val>herr_JECdown_min_max[1]) herr_JECdown_min_max[1] = herr_JECdown_val;
//         if(herr_JERup_val>herr_JERup_min_max[1]) herr_JERup_min_max[1] = herr_JERup_val;
//         if(herr_JERdown_val>herr_JERdown_min_max[1]) herr_JERdown_min_max[1] = herr_JERdown_val;
//         if(herr_response_up_val>herr_response_up_min_max[1]) herr_response_up_min_max[1] = herr_response_up_val;
//         if(herr_Centup_val>herr_Centup_min_max[1]) herr_Centup_min_max[1] = herr_Centup_val;
//         if(herr_Centdown_val>herr_Centdown_min_max[1]) herr_Centdown_min_max[1] = herr_Centdown_val;
//         if(herr_Pythia_prior_up_val>herr_Pythia_prior_up_min_max[1]) herr_Pythia_prior_up_min_max[1] = herr_Pythia_prior_up_val;
//         if(herr_total_up_val>herr_total_up_min_max[1]) herr_total_up_min_max[1] = herr_total_up_val;
//         if(herr_total_down_val>herr_total_down_min_max[1]) herr_total_down_min_max[1] = herr_total_down_val;
//     }

//     std::cout<<"\n\n|Stat| Regularization | Purity | JEC up | JEC down | JER up | JER down | Response | Centrality up | Centrality down | MC Modelling | Total up| Total down|\n";
//     std::cout<<"|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n";
//     printf("|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|%.1f - %.1f|\n",
//     herr_nom_min_max[0],herr_nom_min_max[1],
//     herr_unfoldp1_min_max[0],herr_unfoldp1_min_max[1],
//     herr_purity_up_min_max[0],herr_purity_up_min_max[1],
//     herr_JECup_min_max[0],herr_JECup_min_max[1],
//     herr_JECdown_min_max[0],herr_JECdown_min_max[1],
//     herr_JERup_min_max[0],herr_JERup_min_max[1],
//     herr_JERdown_min_max[0],herr_JERdown_min_max[1],
//     herr_response_up_min_max[0],herr_response_up_min_max[1],
//     herr_Centup_min_max[0],herr_Centup_min_max[1],
//     herr_Centdown_min_max[0],herr_Centdown_min_max[1],
//     herr_Pythia_prior_up_min_max[0],herr_Pythia_prior_up_min_max[1],
//     herr_total_up_min_max[0],herr_total_up_min_max[1],
//     herr_total_down_min_max[0],herr_total_down_min_max[1]);

// }


int main(int argc, char* argv[]){
    if(argc==2){ //! Correct this
        plot_combine(argv[1],argv[2]);
    }
    else{
        printf("Run with \n ./plot_combine <output dir> <label> <file1> <file2> <flag> <xJ bin> <<x label>>\n");
    }
}


void Plot_hist(std::vector<TH1D*> hist,std::vector<TString> histname,TString opt,std::vector<TString> eopt){
    // opt contains options
    // "eff" = Efficiency Plot. Divide by 0th index
    // "left","right", "bcenter" = Legend location 
    // "label" = 2 before the last entries of histname is the X and Y label otherwise use the default 
    // "log" = Set log scale
    // "width" = Divide by Bin Width
    // "OBJ" = optional stuff for later? 

    gStyle->SetOptStat(0);      // No Stat Box
    gStyle->SetOptTitle(0);     // No Title
    // gStyle->SetPadTickX(1);
    gStyle->SetPadTickY(1);
    if(opt.Contains("log")) gStyle->SetOptLogy(1);
    
    TString drawopt = "nostackE][P0"; 
    if(opt.Contains("opt"))
        drawopt = eopt.back();
        /*
    const std::vector<int> colarray  = { 1,632,600,616,419,800,425,898,
                                       922,910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> markarray = {20, 25, 22, 32, 29, 28, 39, 40,
                                        24, 21, 26, 23, 30, 34, 37, 41};*/

    // gStyle->SetPalette(1);
    TColor *pal = new TColor();
    /*
    // good for primary marker colors                                                                                             

    Int_t kmagenta = pal->GetColor(124,  0,124);
    Int_t kviolet  = pal->GetColor( 72,  0,190);
    Int_t kblue    = pal->GetColor(  9,  0,200);
    Int_t kazure   = pal->GetColor(  0, 48, 97);
    Int_t kcyan    = pal->GetColor(  0, 83, 98);
    Int_t kteal    = pal->GetColor(  0, 92, 46);
    Int_t kgreen   = pal->GetColor( 15, 85, 15);
    Int_t kspring  = pal->GetColor( 75, 97, 53);
    Int_t kyellow  = pal->GetColor(117,118,  0);
    Int_t korange  = pal->GetColor(101, 42,  0);
    Int_t kred     = pal->GetColor(190,  0,  3);
    Int_t kpink    = pal->GetColor(180, 35,145);

    Int_t kmagentaLight = pal->GetColor(215,165,215);
    Int_t kvioletLight  = pal->GetColor(200,160,255);
    Int_t kblueLight    = pal->GetColor(178,185,254);
    Int_t kazureLight   = pal->GetColor(153,195,225);
    Int_t kcyanLight    = pal->GetColor(140,209,224);
    Int_t ktealLight    = pal->GetColor( 92,217,141);
    Int_t kgreenLight   = pal->GetColor(135,222,135);
    Int_t kspringLight  = pal->GetColor(151,207,116);
    Int_t kyellowLight  = pal->GetColor(225,225,100);
    Int_t korangeLight  = pal->GetColor(255,168,104);
    Int_t kredLight     = pal->GetColor(253,169,179);
    Int_t kpinkLight    = pal->GetColor(255,192,224);
    

    // 15 Color-Blind Friendly RGB

    Int_t kblack  = pal->GetColor(  0,  0,  0);
    Int_t kteal   = pal->GetColor(  0, 73, 73);
    Int_t kpink   = pal->GetColor(255,109,182);
    Int_t kpurple = pal->GetColor( 73,  0,146);
    Int_t kblue   = pal->GetColor(  0,109,219);
    Int_t kviolet = pal->GetColor(182,109,255);
    Int_t kred    = pal->GetColor(146,  0,  0);
    Int_t kbrown  = pal->GetColor(146, 73,  0);
    Int_t korange = pal->GetColor(219,109,  0);
    Int_t kgreen  = pal->GetColor( 36,255, 36);

    Int_t kolive  = pal->GetColor(  0,146,146);  // 
    Int_t kyellow = pal->GetColor(255,255,109);
    Int_t klpink  = pal->GetColor(255,109,182);  //
    Int_t klblue  = pal->GetColor(109,182,255);  //
    Int_t kvlblue = pal->GetColor(182,219,255);  //
*/
    // 
    Int_t kblack   = pal->GetColor(  0,  0,  0);// pal->GetColor("#000000");
    
    Int_t kred     = pal->GetColor(255,  0,  0);
    Int_t kskyblue = pal->GetColor(  0,114,178);// pal->GetColor("#0072B2");

    Int_t kgrass   = pal->GetColor(  0,158,115);// pal->GetColor("#009E73");
    Int_t kpink    = pal->GetColor(204,121,167);// pal->GetColor("#CC79A7");
    Int_t kpurple  = pal->GetColor( 51, 34,136);// pal->GetColor("#332288");
    Int_t korange  = pal->GetColor(230,159,  0);// pal->GetColor("#E69F00");
    Int_t klblue   = pal->GetColor( 86,180,233);// pal->GetColor("#56B4E9");
    Int_t kyellow  = pal->GetColor(240,228, 66);// pal->GetColor("#F0E442");
    Int_t kviolet  = pal->GetColor(170, 51,119);// pal->GetColor("#AA3377");
    Int_t kredish  = pal->GetColor(213, 94,  0);// pal->GetColor("#D55E00");  
    Int_t kteal   = pal->GetColor(  0, 73, 73);

    // const std::vector<int> colarray  = { kOrange+4,kOrange+4,kCyan+2, kCyan+2 , 600, 600, 616, 616, 419, 419,922,922,kspring,kspring,632, 632, 1, 1,
    //                                    910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> colarray  = { korange, korange,                          // Statistical                                      
                                         kteal, kteal,                              // Regularization
                                         kviolet, kviolet,                          // Purity
                                         kskyblue, kskyblue,                        // JEC
                                         kgrass,kgrass,                             // JER
                                         kpink,kpink,                               // Response 
                                         klblue, klblue,                            // Substructure
                                         kpurple, kpurple,                          // Centrality
                                         kredish, kredish,                          // MC
                                         kblack,kblack                              // Total

    };
    const std::vector<int> markarray = { kOpenCircle, kFullCircle,                  // Statistical                                      
                                         kOpenTriangleUp, kFullTriangleUp,          // Regularization
                                         kOpenDiamond, kFullDiamond,                // Purity
                                         kOpenCross, kFullCross,                    // JEC
                                         kOpenTriangleDown,kFullTriangleDown,       // JER
                                         kOpenDoubleDiamond,kFullDoubleDiamond,     // Response 
                                         kOpenCrossX, kFullCrossX,                  // Substructure
                                         kOpenStar, kFullStar,                      // Centrality
                                         kOpenThreeTriangles, kFullThreeTriangles,  // MC
                                         kOpenSquare, kFullSquare,                  // Total
                                         kOpenCrossX, kFullCrossX
    };

    // TCanvas c;
    c.cd();
    TLegend *l;
    float leg_x1 = 0.6;
    float leg_y1 = 0.58;
    float leg_x2 = 0.8;
    float leg_y2 = 0.88;
    if(opt.Contains("bcenter")){
        leg_x1 = 0.4;
        leg_y1 = 0.15;
        leg_x2 = 0.6;
        leg_y2 = 0.3;
    }
    else if(opt.Contains("left")){
        leg_x1 = 0.15;
        leg_y1 = 0.55;
        leg_x2 = 0.35;
        leg_y2 = 0.88;
    }
    l = new TLegend(leg_x1, leg_y1, leg_x2, leg_y2,"","brNDC");
    l->SetFillStyle(0);
    l->SetFillColor(0);
    l->SetLineColor(0);
    l->SetTextSize(0.035);
    l->SetTextFont(42);

    THStack hs("hs","hs");

    for(std::size_t ihist=0; ihist<hist.size();){
        if(opt.Contains("eff")){
            if((ihist+1)>=hist.size()) break;
            hist[ihist+1]->SetLineColor(colarray[ihist]);
            hist[ihist+1]->SetFillColor(colarray[ihist]);
            hist[ihist+1]->SetMarkerColor(colarray[ihist]);
            hist[ihist+1]->SetMarkerStyle(markarray[ihist]);
            hist[ihist+1]->Divide(hist[ihist+1],hist[0],1,1);
            ihist++;
        }
        else{
            hist[ihist]->SetLineColor(colarray[ihist]);
            hist[ihist]->SetFillColor(colarray[ihist]);
            hist[ihist]->SetMarkerColor(colarray[ihist]);
            hist[ihist]->SetMarkerStyle(markarray[ihist]);
        }
        if(opt.Contains("norm_width")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2),"width");
        }
        else if(opt.Contains("norm")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2));
        }
        if(opt.Contains("flow"))
            hist[ihist]->GetXaxis()->SetRange(0,hist[ihist]->GetNbinsX()+2);

        // hist[ihist]->GetXaxis()->SetRange(1,hist[ihist]->GetNbinsX()-1);
        hs.Add(hist[ihist]);     
        if(ihist%2==1) 
        l->AddEntry(hist[ihist], histname[ihist], "f");
        if(!opt.Contains("eff")) ihist++;
    }
    hs.Draw(drawopt);
    hs.GetHistogram()->GetXaxis()->SetTickLength(0);
    // hs.Draw("NOSTACKB_HIST");
    double uncert_min = -0.2;
    double uncert_max =  0.4;

    hs.SetMinimum(uncert_min);
    hs.SetMaximum(uncert_max);
    // if(hs.GetMinimum()>=uncert_min){
    //     hs.SetMinimum(uncert_min);
    // }
    // else{
    //     hs.SetMinimum(hs.GetMinimum()*1.1);
    // }
    // if(hs.GetMaximum()<=uncert_max){
    //     hs.SetMaximum(uncert_max);
    // }
    // else{
    //     hs.SetMinimum(hs.GetMinimum()*1.1);
    // }
    hs.GetYaxis()->SetTitleOffset(0.9);
    //! TO remove Overflow Bin -> Also remove Line +1
    hs.GetXaxis()->SetRange(1,hist[0]->GetNbinsX()-1);
    if(opt.Contains("label")){
        hs.GetXaxis()->SetTitle(histname.at(histname.size()-3));
        hs.GetYaxis()->SetTitle(histname.at(histname.size()-2));
    }
    else{
        hs.GetXaxis()->SetTitle(hist[0]->GetXaxis()->GetTitle());
        hs.GetYaxis()->SetTitle(hist[0]->GetYaxis()->GetTitle());
    }
    l->Draw();

    TLine *line=new TLine(hist[0]->GetXaxis()->GetXmin(),0.0,hist[0]->GetXaxis()->GetBinLowEdge(hist[0]->GetNbinsX()),0.0);
    line->SetLineStyle(2);
    line->Draw("SAME");

    for(std::size_t ibin=2;ibin<hist[0]->GetNbinsX();ibin++){
        TLine *l_temp=new TLine(hist[0]->GetXaxis()->GetBinLowEdge(ibin),uncert_min,hist[0]->GetXaxis()->GetBinLowEdge(ibin),uncert_max);
        l_temp->SetLineColor(1);
        l_temp->SetLineWidth(1);
        l_temp->SetLineStyle(2);
        l_temp->Draw("SAME");
    }

    TLatex latex;
    latex.SetTextSize(0.035);
    if(label.Contains("Data"))
        latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary}}");
    else
        latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary Simulation}}");

    if(eopt[0].Contains("Cent")){
        latex.DrawLatexNDC(0.75,0.92,eopt[0]);
    }
    else if(eopt.size()>=2){
        latex.DrawLatexNDC(0.41,0.92,eopt[0]);
        latex.DrawLatexNDC(0.6,0.92,eopt[1]);
    }    

    //! Text in Right
    leg_x1 = 0.6;
    leg_y1 = 0.88;

    latex.SetTextSize(0.035);
    if(eopt.size()>2){
        for(std::size_t ind=2;ind<eopt.size() && !eopt[ind].Contains("end"); ind++){
            leg_y1-=0.06;
            latex.DrawLatexNDC(leg_x1,leg_y1,eopt[ind]);            
        }
    }
    gPad->Update();
    c.SaveAs(output_path +histname.back()+".png");
    c.SaveAs(output_path +histname.back()+".C");
    c.Write(histname.back(),TObject::kWriteDelete);
    std::cout<<histname.back()<<" has been saved"<<std::endl;
    // delete l;
    if(opt.Contains("log")) gStyle->SetOptLogy(0);
    return c;
}


void Plot_hist_up(std::vector<TH1D*> hist,std::vector<TString> histname,TString opt,std::vector<TString> eopt){
    // opt contains options
    // "eff" = Efficiency Plot. Divide by 0th index
    // "left","right", "bcenter" = Legend location 
    // "label" = 2 before the last entries of histname is the X and Y label otherwise use the default 
    // "log" = Set log scale
    // "width" = Divide by Bin Width
    // "OBJ" = optional stuff for later? 

    gStyle->SetOptStat(0);      // No Stat Box
    gStyle->SetOptTitle(0);     // No Title
    // gStyle->SetPadTickX(1);
    gStyle->SetPadTickY(1);
    if(opt.Contains("log")) gStyle->SetOptLogy(1);
    
    TString drawopt = "nostackE][P0"; 
    if(opt.Contains("opt"))
        drawopt = eopt.back();
        /*
    const std::vector<int> colarray  = { 1,632,600,616,419,800,425,898,
                                       922,910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> markarray = {20, 25, 22, 32, 29, 28, 39, 40,
                                        24, 21, 26, 23, 30, 34, 37, 41};*/

    // gStyle->SetPalette(1);
    TColor *pal = new TColor();
    /*
    // good for primary marker colors                                                                                             

    Int_t kmagenta = pal->GetColor(124,  0,124);
    Int_t kviolet  = pal->GetColor( 72,  0,190);
    Int_t kblue    = pal->GetColor(  9,  0,200);
    Int_t kazure   = pal->GetColor(  0, 48, 97);
    Int_t kcyan    = pal->GetColor(  0, 83, 98);
    Int_t kteal    = pal->GetColor(  0, 92, 46);
    Int_t kgreen   = pal->GetColor( 15, 85, 15);
    Int_t kspring  = pal->GetColor( 75, 97, 53);
    Int_t kyellow  = pal->GetColor(117,118,  0);
    Int_t korange  = pal->GetColor(101, 42,  0);
    Int_t kred     = pal->GetColor(190,  0,  3);
    Int_t kpink    = pal->GetColor(180, 35,145);

    Int_t kmagentaLight = pal->GetColor(215,165,215);
    Int_t kvioletLight  = pal->GetColor(200,160,255);
    Int_t kblueLight    = pal->GetColor(178,185,254);
    Int_t kazureLight   = pal->GetColor(153,195,225);
    Int_t kcyanLight    = pal->GetColor(140,209,224);
    Int_t ktealLight    = pal->GetColor( 92,217,141);
    Int_t kgreenLight   = pal->GetColor(135,222,135);
    Int_t kspringLight  = pal->GetColor(151,207,116);
    Int_t kyellowLight  = pal->GetColor(225,225,100);
    Int_t korangeLight  = pal->GetColor(255,168,104);
    Int_t kredLight     = pal->GetColor(253,169,179);
    Int_t kpinkLight    = pal->GetColor(255,192,224);
    

    // 15 Color-Blind Friendly RGB

    Int_t kblack  = pal->GetColor(  0,  0,  0);
    Int_t kteal   = pal->GetColor(  0, 73, 73);
    Int_t kpink   = pal->GetColor(255,109,182);
    Int_t kpurple = pal->GetColor( 73,  0,146);
    Int_t kblue   = pal->GetColor(  0,109,219);
    Int_t kviolet = pal->GetColor(182,109,255);
    Int_t kred    = pal->GetColor(146,  0,  0);
    Int_t kbrown  = pal->GetColor(146, 73,  0);
    Int_t korange = pal->GetColor(219,109,  0);
    Int_t kgreen  = pal->GetColor( 36,255, 36);

    Int_t kolive  = pal->GetColor(  0,146,146);  // 
    Int_t kyellow = pal->GetColor(255,255,109);
    Int_t klpink  = pal->GetColor(255,109,182);  //
    Int_t klblue  = pal->GetColor(109,182,255);  //
    Int_t kvlblue = pal->GetColor(182,219,255);  //
    */
    // 

    Int_t kblack   = pal->GetColor(  0,  0,  0);// pal->GetColor("#000000");
    
    Int_t kred     = pal->GetColor(255,  0,  0);
    Int_t kskyblue = pal->GetColor(  0,114,178);// pal->GetColor("#0072B2");

    Int_t kgrass   = pal->GetColor(  0,158,115);// pal->GetColor("#009E73");
    Int_t kpink    = pal->GetColor(204,121,167);// pal->GetColor("#CC79A7");
    Int_t kpurple  = pal->GetColor( 51, 34,136);// pal->GetColor("#332288");
    Int_t korange  = pal->GetColor(230,159,  0);// pal->GetColor("#E69F00");
    Int_t klblue   = pal->GetColor( 86,180,233);// pal->GetColor("#56B4E9");
    Int_t kyellow  = pal->GetColor(240,228, 66);// pal->GetColor("#F0E442");
    Int_t kviolet  = pal->GetColor(170, 51,119);// pal->GetColor("#AA3377");
    Int_t kredish  = pal->GetColor(213, 94,  0);// pal->GetColor("#D55E00");  
    Int_t kteal   = pal->GetColor(  0, 73, 73);
    // const std::vector<int> colarray  = { kOrange+4,kOrange+4,kCyan+2, kCyan+2 , 600, 600, 616, 616, 419, 419,922,922,kspring,kspring,632, 632, 1, 1,
    //                                    910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> colarray  = { 0,0,0,// korange,                      // Statistical                                      
                                         // kteal,                     // Regularization
                                         // kviolet,                      // Purity
                                         // kskyblue,                     // JEC
                                         // kgrass,                       // JER
                                         // kpink,                        // Response 
                                         // klblue,                       // Substructure
                                         // kpurple,                      // Centrality
                                         // kredish,                      // MC
                                         kblack                        // Total

    };
    const std::vector<int> markarray = { kOpenCircle, kFullCircle,                  // Statistical                                      
                                         kOpenTriangleUp, kFullTriangleUp,          // Regularization
                                         kOpenDiamond, kFullDiamond,                // Purity
                                         kOpenCross, kFullCross,                    // JEC
                                         kOpenTriangleDown,kFullTriangleDown,       // JER
                                         kOpenDoubleDiamond,kFullDoubleDiamond,     // Response 
                                         kOpenCrossX, kFullCrossX,                  // Substructure
                                         kOpenStar, kFullStar,                      // Centrality
                                         kOpenThreeTriangles, kFullThreeTriangles,  // MC
                                         kOpenSquare, kFullSquare,                  // Total
                                         kOpenCrossX, kFullCrossX
    };

    // TCanvas c;
    c.cd();
    TLegend *l;
    float leg_x1 = 0.6;
    float leg_y1 = 0.58;
    float leg_x2 = 0.8;
    float leg_y2 = 0.88;
    if(opt.Contains("bcenter")){
        leg_x1 = 0.4;
        leg_y1 = 0.15;
        leg_x2 = 0.6;
        leg_y2 = 0.3;
    }
    else if(opt.Contains("left")){
        leg_x1 = 0.15;
        leg_y1 = 0.55;
        leg_x2 = 0.35;
        leg_y2 = 0.88;
    }
    l = new TLegend(leg_x1, leg_y1, leg_x2, leg_y2,"","brNDC");
    l->SetFillStyle(0);
    l->SetFillColor(0);
    l->SetLineColor(0);
    l->SetTextSize(0.035);
    l->SetTextFont(42);

    THStack *hs = new THStack("hs_up","hs_up");

    for(std::size_t ihist=0; ihist<hist.size();){
        if(opt.Contains("eff")){
            if((ihist+1)>=hist.size()) break;
            hist[ihist+1]->SetLineColor(colarray[ihist]);
            hist[ihist+1]->SetFillColor(colarray[ihist]);
            hist[ihist+1]->SetMarkerColor(colarray[ihist]);
            hist[ihist+1]->SetMarkerStyle(markarray[ihist]);
            hist[ihist+1]->Divide(hist[ihist+1],hist[0],1,1);
            ihist++;
        }
        else{
            hist[ihist]->SetLineColor(colarray[ihist]);
            hist[ihist]->SetFillColor(colarray[ihist]);
            hist[ihist]->SetMarkerColor(colarray[ihist]);
            hist[ihist]->SetMarkerStyle(markarray[ihist]);
        }
        if(opt.Contains("norm_width")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2),"width");
        }
        else if(opt.Contains("norm")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2));
        }
        if(opt.Contains("flow"))
            hist[ihist]->GetXaxis()->SetRange(0,hist[ihist]->GetNbinsX()+2);

        // hist[ihist]->GetXaxis()->SetRange(1,hist[ihist]->GetNbinsX()-1);
        hs->Add(hist[ihist]);     
        // if(ihist%2==1) 
        l->AddEntry(hist[ihist], histname[ihist], "f");
        if(!opt.Contains("eff")) ihist++;
    }
    hs->Draw(drawopt);
    hs->GetHistogram()->GetXaxis()->SetTickLength(0);
    // hs->Draw("NOSTACKB_HIST");
    double uncert_min = -0.2;
    double uncert_max =  0.4;

    hs->SetMinimum(uncert_min);
    hs->SetMaximum(uncert_max);
    // if(hs->GetMinimum()>=uncert_min){
    //     hs->SetMinimum(uncert_min);
    // }
    // else{
    //     hs->SetMinimum(hs->GetMinimum()*1.1);
    // }
    // if(hs->GetMaximum()<=uncert_max){
    //     hs->SetMaximum(uncert_max);
    // }
    // else{
    //     hs->SetMinimum(hs->GetMinimum()*1.1);
    // }
    hs->GetYaxis()->SetTitleOffset(0.9);
    //! TO remove Overflow Bin -> Also remove Line +1
    hs->GetXaxis()->SetRange(1,hist[0]->GetNbinsX()-1);
    if(opt.Contains("label")){
        hs->GetXaxis()->SetTitle(histname.at(histname.size()-3));
        hs->GetYaxis()->SetTitle(histname.at(histname.size()-2));
    }
    else{
        hs->GetXaxis()->SetTitle(hist[0]->GetXaxis()->GetTitle());
        hs->GetYaxis()->SetTitle(hist[0]->GetYaxis()->GetTitle());
    }
    // l->Draw();

    // TLine *line=new TLine(hist[0]->GetXaxis()->GetXmin(),0.0,hist[0]->GetXaxis()->GetBinLowEdge(hist[0]->GetNbinsX()+1),0.0);
    // line->SetLineStyle(2);
    // line->Draw("SAME");

    // for(std::size_t ibin=2;ibin<hist[0]->GetNbinsX()+1;ibin++){
    //     TLine *l_temp=new TLine(hist[0]->GetXaxis()->GetBinLowEdge(ibin),uncert_min,hist[0]->GetXaxis()->GetBinLowEdge(ibin),uncert_max);
    //     l_temp->SetLineColor(1);
    //     l_temp->SetLineWidth(1);
    //     l_temp->SetLineStyle(2);
    //     l_temp->Draw("SAME");
    // }

    // TLatex latex;
    // latex.SetTextSize(0.035);
    // if(label.Contains("Data"))
    //     latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary}}");
    // else
    //     latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary Simulation}}");

    // if(eopt[0].Contains("Cent")){
    //     latex.DrawLatexNDC(0.75,0.92,eopt[0]);
    // }
    // else if(eopt.size()>=2){
    //     latex.DrawLatexNDC(0.41,0.92,eopt[0]);
    //     latex.DrawLatexNDC(0.6,0.92,eopt[1]);
    // }    

    //! Text in Right
    leg_x1 = 0.6;
    leg_y1 = 0.88;

    // latex.SetTextSize(0.035);
    // if(eopt.size()>2){
    //     for(std::size_t ind=2;ind<eopt.size() && !eopt[ind].Contains("end"); ind++){
    //         leg_y1-=0.06;
    //         latex.DrawLatexNDC(leg_x1,leg_y1,eopt[ind]);
    //     }
    // }
    gPad->Update();
    // c.SaveAs(output_path +histname.back()+".png");
    // c.SaveAs(output_path +histname.back()+".C");
    // c.Write(histname.back(),TObject::kWriteDelete);
    // std::cout<<histname.back()<<" has been saved"<<std::endl;
    // delete l;
    if(opt.Contains("log")) gStyle->SetOptLogy(0);
    return c;
}


void Plot_hist_down(std::vector<TH1D*> hist,std::vector<TString> histname,TString opt,std::vector<TString> eopt){
    // opt contains options
    // "eff" = Efficiency Plot. Divide by 0th index
    // "left","right", "bcenter" = Legend location 
    // "label" = 2 before the last entries of histname is the X and Y label otherwise use the default 
    // "log" = Set log scale
    // "width" = Divide by Bin Width
    // "OBJ" = optional stuff for later? 

    gStyle->SetOptStat(0);      // No Stat Box
    gStyle->SetOptTitle(0);     // No Title
    // gStyle->SetPadTickX(1);
    gStyle->SetPadTickY(1);
    if(opt.Contains("log")) gStyle->SetOptLogy(1);
    
    TString drawopt = "nostackE][P0"; 
    if(opt.Contains("opt"))
        drawopt = eopt.back();
        /*
    const std::vector<int> colarray  = { 1,632,600,616,419,800,425,898,
                                       922,910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> markarray = {20, 25, 22, 32, 29, 28, 39, 40,
                                        24, 21, 26, 23, 30, 34, 37, 41};*/

    // gStyle->SetPalette(1);
    TColor *pal = new TColor();
    /*
    // good for primary marker colors                                                                                             

    Int_t kmagenta = pal->GetColor(124,  0,124);
    Int_t kviolet  = pal->GetColor( 72,  0,190);
    Int_t kblue    = pal->GetColor(  9,  0,200);
    Int_t kazure   = pal->GetColor(  0, 48, 97);
    Int_t kcyan    = pal->GetColor(  0, 83, 98);
    Int_t kteal    = pal->GetColor(  0, 92, 46);
    Int_t kgreen   = pal->GetColor( 15, 85, 15);
    Int_t kspring  = pal->GetColor( 75, 97, 53);
    Int_t kyellow  = pal->GetColor(117,118,  0);
    Int_t korange  = pal->GetColor(101, 42,  0);
    Int_t kred     = pal->GetColor(190,  0,  3);
    Int_t kpink    = pal->GetColor(180, 35,145);

    Int_t kmagentaLight = pal->GetColor(215,165,215);
    Int_t kvioletLight  = pal->GetColor(200,160,255);
    Int_t kblueLight    = pal->GetColor(178,185,254);
    Int_t kazureLight   = pal->GetColor(153,195,225);
    Int_t kcyanLight    = pal->GetColor(140,209,224);
    Int_t ktealLight    = pal->GetColor( 92,217,141);
    Int_t kgreenLight   = pal->GetColor(135,222,135);
    Int_t kspringLight  = pal->GetColor(151,207,116);
    Int_t kyellowLight  = pal->GetColor(225,225,100);
    Int_t korangeLight  = pal->GetColor(255,168,104);
    Int_t kredLight     = pal->GetColor(253,169,179);
    Int_t kpinkLight    = pal->GetColor(255,192,224);
    

    // 15 Color-Blind Friendly RGB

    Int_t kblack  = pal->GetColor(  0,  0,  0);
    Int_t kteal   = pal->GetColor(  0, 73, 73);
    Int_t kpink   = pal->GetColor(255,109,182);
    Int_t kpurple = pal->GetColor( 73,  0,146);
    Int_t kblue   = pal->GetColor(  0,109,219);
    Int_t kviolet = pal->GetColor(182,109,255);
    Int_t kred    = pal->GetColor(146,  0,  0);
    Int_t kbrown  = pal->GetColor(146, 73,  0);
    Int_t korange = pal->GetColor(219,109,  0);
    Int_t kgreen  = pal->GetColor( 36,255, 36);

    Int_t kolive  = pal->GetColor(  0,146,146);  // 
    Int_t kyellow = pal->GetColor(255,255,109);
    Int_t klpink  = pal->GetColor(255,109,182);  //
    Int_t klblue  = pal->GetColor(109,182,255);  //
    Int_t kvlblue = pal->GetColor(182,219,255);  //
    */
    // 

    Int_t kblack   = pal->GetColor(  0,  0,  0);// pal->GetColor("#000000");
    
    Int_t kred     = pal->GetColor(255,  0,  0);
    Int_t kskyblue = pal->GetColor(  0,114,178);// pal->GetColor("#0072B2");

    Int_t kgrass   = pal->GetColor(  0,158,115);// pal->GetColor("#009E73");
    Int_t kpink    = pal->GetColor(204,121,167);// pal->GetColor("#CC79A7");
    Int_t kpurple  = pal->GetColor( 51, 34,136);// pal->GetColor("#332288");
    Int_t korange  = pal->GetColor(230,159,  0);// pal->GetColor("#E69F00");
    Int_t klblue   = pal->GetColor( 86,180,233);// pal->GetColor("#56B4E9");
    Int_t kyellow  = pal->GetColor(240,228, 66);// pal->GetColor("#F0E442");
    Int_t kviolet  = pal->GetColor(170, 51,119);// pal->GetColor("#AA3377");
    Int_t kredish  = pal->GetColor(213, 94,  0);// pal->GetColor("#D55E00");  
    Int_t kteal   = pal->GetColor(  0, 73, 73);
    // const std::vector<int> colarray  = { kOrange+4,kOrange+4,kCyan+2, kCyan+2 , 600, 600, 616, 616, 419, 419,922,922,kspring,kspring,632, 632, 1, 1,
    //                                    910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> colarray  = { 0,0,0,// korange,                      // Statistical                                      
                                         // kteal,                     // Regularization
                                         // kviolet,                      // Purity
                                         // kskyblue,                     // JEC
                                         // kgrass,                       // JER
                                         // kpink,                        // Response 
                                         // klblue,                       // Substructure
                                         // kpurple,                      // Centrality
                                         // kredish,                      // MC
                                         kblack                        // Total

    };
    const std::vector<int> markarray = { kOpenCircle, kFullCircle,                  // Statistical                                      
                                         kOpenTriangleUp, kFullTriangleUp,          // Regularization
                                         kOpenDiamond, kFullDiamond,                // Purity
                                         kOpenCross, kFullCross,                    // JEC
                                         kOpenTriangleDown,kFullTriangleDown,       // JER
                                         kOpenDoubleDiamond,kFullDoubleDiamond,     // Response 
                                         kOpenCrossX, kFullCrossX,                  // Substructure
                                         kOpenStar, kFullStar,                      // Centrality
                                         kOpenThreeTriangles, kFullThreeTriangles,  // MC
                                         kOpenSquare, kFullSquare,                  // Total
                                         kOpenCrossX, kFullCrossX
    };

    // TCanvas c;
    c.cd();
    c.SetTicky(1);
    TLegend *l;
    float leg_x1 = 0.6;
    float leg_y1 = 0.58;
    float leg_x2 = 0.8;
    float leg_y2 = 0.88;
    if(opt.Contains("bcenter")){
        leg_x1 = 0.4;
        leg_y1 = 0.15;
        leg_x2 = 0.6;
        leg_y2 = 0.3;
    }
    else if(opt.Contains("left")){
        leg_x1 = 0.15;
        leg_y1 = 0.55;
        leg_x2 = 0.35;
        leg_y2 = 0.88;
    }
    l = new TLegend(leg_x1, leg_y1, leg_x2, leg_y2,"","brNDC");
    l->SetFillStyle(0);
    l->SetFillColor(0);
    l->SetLineColor(0);
    l->SetTextSize(0.035);
    l->SetTextFont(42);

    THStack *hs = new THStack("hs_down","hs_down");

    for(std::size_t ihist=0; ihist<hist.size();){
        if(opt.Contains("eff")){
            if((ihist+1)>=hist.size()) break;
            hist[ihist+1]->SetLineColor(colarray[ihist]);
            hist[ihist+1]->SetFillColor(colarray[ihist]);
            hist[ihist+1]->SetMarkerColor(colarray[ihist]);
            hist[ihist+1]->SetMarkerStyle(markarray[ihist]);
            hist[ihist+1]->Divide(hist[ihist+1],hist[0],1,1);
            ihist++;
        }
        else{
            hist[ihist]->SetLineColor(colarray[ihist]);
            hist[ihist]->SetFillColor(colarray[ihist]);
            hist[ihist]->SetMarkerColor(colarray[ihist]);
            hist[ihist]->SetMarkerStyle(markarray[ihist]);
        }
        if(opt.Contains("norm_width")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2),"width");
        }
        else if(opt.Contains("norm")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2));
        }
        if(opt.Contains("flow"))
            hist[ihist]->GetXaxis()->SetRange(0,hist[ihist]->GetNbinsX()+2);

        // hist[ihist]->GetXaxis()->SetRange(1,hist[ihist]->GetNbinsX()-1);
        hs->Add(hist[ihist]);     
        //if(ihist%2==1) 
        l->AddEntry(hist[ihist], histname[ihist], "f");
        if(!opt.Contains("eff")) ihist++;
    }
    hs->Draw(drawopt);
    hs->GetHistogram()->GetXaxis()->SetTickLength(0);
    // hs->Draw("NOSTACKB_HIST");
    double uncert_min = -0.2;
    double uncert_max =  0.4;

    hs->SetMinimum(uncert_min);
    hs->SetMaximum(uncert_max);
    // if(hs->GetMinimum()>=uncert_min){
    //     hs->SetMinimum(uncert_min);
    // }
    // else{
    //     hs->SetMinimum(hs->GetMinimum()*1.1);
    // }
    // if(hs->GetMaximum()<=uncert_max){
    //     hs->SetMaximum(uncert_max);
    // }
    // else{
    //     hs->SetMinimum(hs->GetMinimum()*1.1);
    // }
    hs->GetYaxis()->SetTitleOffset(0.9);
    //! TO remove Overflow Bin -> Also remove Line +1
    hs->GetXaxis()->SetRange(1,hist[0]->GetNbinsX()-1);
    if(opt.Contains("label")){
        hs->GetXaxis()->SetTitle(histname.at(histname.size()-3));
        hs->GetYaxis()->SetTitle(histname.at(histname.size()-2));
    }
    else{
        hs->GetXaxis()->SetTitle(hist[0]->GetXaxis()->GetTitle());
        hs->GetYaxis()->SetTitle(hist[0]->GetYaxis()->GetTitle());
    }
    l->Draw();

    TLine *line=new TLine(hist[0]->GetXaxis()->GetXmin(),0.0,hist[0]->GetXaxis()->GetBinLowEdge(hist[0]->GetNbinsX()),0.0);
    line->SetLineStyle(2);
    line->SetLineWidth(2);
    line->Draw("SAME");

    for(std::size_t ibin=2;ibin<hist[0]->GetNbinsX();ibin++){
        TLine *l_temp=new TLine(hist[0]->GetXaxis()->GetBinLowEdge(ibin),uncert_min,hist[0]->GetXaxis()->GetBinLowEdge(ibin),uncert_max);
        l_temp->SetLineColor(1);
        l_temp->SetLineWidth(1);
        l_temp->SetLineStyle(2);
        l_temp->Draw("SAME");
    }

    TLatex latex;
    latex.SetTextSize(0.035);
    if(label.Contains("Data"))
        latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary}}");
    else
        latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary Simulation}}");

    if(eopt[0].Contains("Cent")){
        latex.DrawLatexNDC(0.75,0.92,eopt[0]);
    }
    else if(eopt.size()>=2){
        latex.DrawLatexNDC(0.41,0.92,eopt[0]);
        latex.DrawLatexNDC(0.6,0.92,eopt[1]);
    }    

    //! Text in Right
    leg_x1 = 0.6;
    leg_y1 = 0.88;

    latex.SetTextSize(0.035);
    if(eopt.size()>2){
        for(std::size_t ind=2;ind<eopt.size() && !eopt[ind].Contains("end"); ind++){
            leg_y1-=0.06;
            latex.DrawLatexNDC(leg_x1,leg_y1,eopt[ind]);
        }
    }
    gPad->Update();
    c.SaveAs(output_path +histname.back()+".png");
    // c.SaveAs(output_path +histname.back()+".C");
    c.Write(histname.back(),TObject::kWriteDelete);
    std::cout<<histname.back()<<" has been saved"<<std::endl;
    // delete l;
    if(opt.Contains("log")) gStyle->SetOptLogy(0);
    return c;
}


void overlay(std::vector<TH1D*> hist,std::vector<TString> histname,TString opt,std::vector<TString> eopt){
    // Based on the old Ratio Plot script from https://root.cern/doc/master/ratioplotOld_8C.html

    // opt contains options
    // "left","right", "bcenter" = Legend location 
    // "label" = 2 before the last entries of histname is the X and Y label otherwise use the default 
    // "log" = Set log scale
    // "width" = Divide by Bin Width
    // "opt" = drawopt is last element of eopt

    if(hist.size()<2){
        std::cout<<"Not Enough Histograms"<<std::endl;
        return;
    }

    gStyle->SetOptStat(0);      // No Stat Box
    gStyle->SetOptTitle(0);     // No Title
    gStyle->SetPadTickX(1);
    gStyle->SetPadTickY(1);
    gStyle->SetHistTopMargin(0);
    if(opt.Contains("log")) gStyle->SetOptLogy(1);
    
    TString drawopt = "E1][P0"; 
    if(opt.Contains("opt"))
        drawopt = eopt.back();
    
    gStyle->SetPalette(1);
    TColor *pal = new TColor();
    /*
    // good for primary marker colors                                                                                             

    Int_t kmagenta = pal->GetColor(124,  0,124);
    Int_t kviolet  = pal->GetColor( 72,  0,190);
    Int_t kblue    = pal->GetColor(  9,  0,200);
    Int_t kazure   = pal->GetColor(  0, 48, 97);
    Int_t kcyan    = pal->GetColor(  0, 83, 98);
    Int_t kteal    = pal->GetColor(  0, 92, 46);
    Int_t kgreen   = pal->GetColor( 15, 85, 15);
    Int_t kspring  = pal->GetColor( 75, 97, 53);
    Int_t kyellow  = pal->GetColor(117,118,  0);
    Int_t korange  = pal->GetColor(101, 42,  0);
    Int_t kred     = pal->GetColor(190,  0,  3);
    Int_t kpink    = pal->GetColor(180, 35,145);

    Int_t kmagentaLight = pal->GetColor(215,165,215);
    Int_t kvioletLight  = pal->GetColor(200,160,255);
    Int_t kblueLight    = pal->GetColor(178,185,254);
    Int_t kazureLight   = pal->GetColor(153,195,225);
    Int_t kcyanLight    = pal->GetColor(140,209,224);
    Int_t ktealLight    = pal->GetColor( 92,217,141);
    Int_t kgreenLight   = pal->GetColor(135,222,135);
    Int_t kspringLight  = pal->GetColor(151,207,116);
    Int_t kyellowLight  = pal->GetColor(225,225,100);
    Int_t korangeLight  = pal->GetColor(255,168,104);
    Int_t kredLight     = pal->GetColor(253,169,179);
    Int_t kpinkLight    = pal->GetColor(255,192,224);
    
*/
// 15 Color-Blind Friendly RGB

    Int_t kblack  = pal->GetColor(  0,  0,  0);
    Int_t kteal   = pal->GetColor(  0, 73, 73);
    Int_t kpink   = pal->GetColor(255,109,182);
    Int_t kpurple = pal->GetColor( 73,  0,146);
    Int_t kblue   = pal->GetColor(  0,109,219);
    Int_t kviolet = pal->GetColor(182,109,255);
    Int_t kred    = pal->GetColor(146,  0,  0);
    Int_t kbrown  = pal->GetColor(146, 73,  0);
    Int_t korange = pal->GetColor(219,109,  0);
    Int_t kgreen  = pal->GetColor( 36,255, 36);

    Int_t kolive  = pal->GetColor(  0,146,146);  // 
    Int_t kyellow = pal->GetColor(255,255,109);  //
    Int_t klpink  = pal->GetColor(255,109,182);  //
    Int_t klblue  = pal->GetColor(109,182,255);  //
    Int_t kvlblue = pal->GetColor(182,219,255);  //
    // const std::vector<int> colarray  = { kbrown,                // Statistical                                      
    //                                      // kteal,                 // Regularization
    //                                      kblue,                 // Purity
    //                                      kviolet,               // JEC
    //                                      kpurple,               // JER
    //                                      kpink,                 // Response 
    //                                      kgreen,                // Substructure
    //                                      kviolet,               // Centrality
    //                                      // kred,                  // MC
    //                                      kblack                 // Total

    // };
    // const std::vector<int> colarray  ={kblack,kred,kblue,kgreen,kbrown,kpink,kteal,kpurple,korange,kviolet,kolive,klblue,kyellow,klpink,kvlblue};
    // const std::vector<int> markarray = { kOpenCircle, kFullCircle,                  // Statistical                                      
    //                                      // kOpenTriangleUp, kFullTriangleUp,          // Regularization
    //                                      kOpenDiamond, kFullDiamond,                // Purity
    //                                      kOpenCross, kFullCross,                    // JEC
    //                                      kOpenTriangleDown,kFullTriangleDown,       // JER
    //                                      kOpenCross, kFullCross,                    // Response 
    //                                      kOpenCrossX, kFullCrossX,                  // Substructure
    //                                      kOpenStar, kFullStar,                      // Centrality
    //                                      // kOpenThreeTriangles, kFullThreeTriangles,   // MC
    //                                      kOpenSquare, kFullSquare,                  // Total
    //                                      kOpenDoubleDiamond,kFullDoubleDiamond,
    //                                      kOpenCrossX, kFullCrossX
    // };
    // const std::vector<int> markarray = {20, 25, 22, 32, 29, 28, 39, 40,
    //                                     24, 21, 26, 23, 30, 34, 37, 41};

    const std::vector<int> colarray  = { 1,632,600,616,419,800,425,898,
                                       922,910,851,877,811,804,434,606,
                                       1,632,600,616,419,800,425,898,
                                       922,910,851,877,811,804,434,606};// { 1, 2, 4, 6, 8,20,28};
    const std::vector<int> markarray = {20, 25, 22, 32, 29, 28, 39, 40,
                                        24, 21, 26, 23, 30, 34, 37, 41};

    
    // TCanvas c;
    c.cd();
    TLegend *l;
    float leg_x1 = 0.65;
    float leg_y1 = 0.5;
    float leg_x2 = 0.9;
    float leg_y2 = 0.8;
    if(opt.Contains("bcenter")){
        leg_x1 = 0.45;
        leg_y1 = 0.2;
        leg_x2 = 0.55;
        leg_y2 = 0.4;
    }
    else if(opt.Contains("left")){
        leg_x1 = 0.15;
        leg_y1 = 0.55;
        leg_x2 = 0.25;
        leg_y2 = 0.82;
    }
    l = new TLegend(leg_x1, leg_y1, leg_x2, leg_y2,"","brNDC");
    l->SetFillStyle(0);
    l->SetFillColor(0);
    l->SetLineColor(0);
    l->SetTextSize(0.035);
    l->SetTextFont(42);
        
    // Upper plot will be in pad1
    TPad *pad1 = new TPad("pad1", "pad1", 0, 0.3, 1, 1.0);
    pad1->SetTopMargin(0.15);
    pad1->SetRightMargin(0.05); 
    pad1->SetLeftMargin(0.12); 
    pad1->SetBottomMargin(0.05); 
    pad1->Draw();             // Draw the upper pad: pad1
    pad1->cd();               // pad1 becomes the current pad
    float ymax = -99999;
    for(std::size_t ihist=0; ihist<hist.size();ihist++){

        hist[ihist]->SetLineColor(colarray[ihist]);
        hist[ihist]->SetMarkerColor(colarray[ihist]);
        hist[ihist]->SetMarkerStyle(markarray[ihist]);        
        if(opt.Contains("norm_width")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2),"width");
        }
        else if(opt.Contains("norm")){
            hist[ihist]->Scale(1.0/hist[ihist]->Integral(0,hist[ihist]->GetNbinsX()+2));
        }
        if(opt.Contains("flow"))
            hist[ihist]->GetXaxis()->SetRange(0,hist[ihist]->GetNbinsX()+2);   
        
        if(hist[ihist]->GetMaximum()>ymax) ymax = hist[ihist]->GetMaximum();
        hist[ihist]->Draw(drawopt);
        hist[ihist]->GetXaxis()->SetLabelSize(0);
        hist[ihist]->GetXaxis()->SetTitleOffset(999999);
        l->AddEntry(hist[ihist], histname[ihist], "lep");
        if(ihist==0) drawopt+="SAME";
    }
    hist[0]->SetMinimum(0.0);
    if(!opt.Contains("log"))
        hist[0]->SetMaximum(ymax*1.1);
    else
        hist[0]->SetMaximum(ymax*2);

    l->Draw();

    TLatex latex;
    latex.SetTextSize(0.05);
    if(label.Contains("Data"))
        latex.DrawLatexNDC(0.1,0.9,"CMS #it{#bf{Preliminary}} #bf{PbPb 1.7 nb^{-1}(5.02 TeV)}");
    else
        latex.DrawLatexNDC(0.1,0.9,"CMS #it{#bf{Preliminary Simulation}}");

    if(eopt[0].Contains("Cent")){
        latex.DrawLatexNDC(0.78,0.9,eopt[0]);
    }
    else if(eopt.size()>=2){
        latex.DrawLatexNDC(0.55,0.9,eopt[0]);
        latex.DrawLatexNDC(0.80,0.9,eopt[1]);
    }    
    latex.SetTextSize(0.035);
    if(eopt.size()>2){
        for(std::size_t ind=2;ind<eopt.size() && !eopt[ind].Contains("end"); ind++){
            if(opt.Contains("bcenter")){
                leg_y2+=0.08;
                latex.DrawLatexNDC(leg_x1,leg_y2,eopt[ind]);
            }
            else{
                leg_y1-=0.08;
                latex.DrawLatexNDC(leg_x1,leg_y1,eopt[ind]);
            }
        }
    }
        
    // lower plot will be in pad
    c.cd();          // Go back to the main canvas before defining pad2
    TPad *pad2 = new TPad("pad2", "pad2", 0, 0, 1, 0.3);
    pad2->SetTopMargin(0.05);
    pad2->SetRightMargin(0.05); 
    pad2->SetLeftMargin(0.12); 
    pad2->SetBottomMargin(0.3); 
    pad2->SetGrid();
    pad2->Draw();
    pad2->cd();       // pad2 becomes the current pad

    // Define the ratio plot
    TH1D *hratio = (TH1D*)hist[0]->Clone(histname[0]);
    for(std::size_t ihist=1; ihist<hist.size();ihist++){
        hratio = (TH1D*)hist[ihist]->Clone(histname[ihist]);
        hratio->SetLineColor(colarray[ihist]);
        hratio->SetMarkerColor(colarray[ihist]);
        hratio->SetMarkerStyle(markarray[ihist]);   

        if(!opt.Contains("log")){
            hratio->SetMinimum(0.5);  // Define Y ..
            hratio->SetMaximum(1.5); // .. range
        }

        // hratio->Sumw2();
        hratio->Divide(hist[0]);
        hratio->Draw(drawopt);

        // Y axis ratio plot settings
        hratio->GetYaxis()->SetTitle("Ratio   ");
        hratio->GetYaxis()->SetNdivisions(10);
        hratio->GetYaxis()->SetTitleSize(0.12);
        hratio->GetYaxis()->SetTitleOffset(0.32);
        hratio->GetYaxis()->SetLabelFont(43); // Absolute font size in pixel (precision 3)
        hratio->GetYaxis()->SetLabelSize(15);
        
        // X axis ratio plot settings
        hratio->GetXaxis()->SetTitleSize(0.12);
        hratio->GetXaxis()->SetTitleOffset(1.0);
        hratio->GetXaxis()->SetLabelFont(43); // Absolute font size in pixel (precision 3)
        hratio->GetXaxis()->SetLabelSize(15);
    }
    c.cd();  

    if(opt.Contains("label")){
        hratio->GetXaxis()->SetTitle(histname.at(histname.size()-3));
        hist[0]->GetYaxis()->SetTitle(histname.at(histname.size()-2));
    }
    else{
        hratio->GetXaxis()->SetTitle(hist[0]->GetXaxis()->GetTitle());
        hist[0]->GetYaxis()->SetTitle(hist[0]->GetYaxis()->GetTitle());
    }

    // Y axis upper plot settings
        hist[0]->GetYaxis()->SetTitleSize(15);
        hist[0]->GetYaxis()->SetTitleFont(43);
        hist[0]->GetYaxis()->SetTitleOffset(1.5);
        hist[0]->GetYaxis()->SetLabelSize(0.05);

    
    gPad->Update();
    c.SaveAs(output_path +histname.back()+".png");
    // c.SaveAs(output_path +histname.back()+".C");
    c.Write(histname.back(),TObject::kOverwrite);
    std::cout<<histname.back()<<" has been saved"<<std::endl;
    // delete l;
    if(opt.Contains("log")) gStyle->SetOptLogy(0);
    return c;
}


void Plot_hist_err(std::vector<TH1D*> hist,std::vector<TGraphAsymmErrors*> err_graph,std::vector<TString> histname,TString opt,std::vector<TString> eopt){
    // opt contains options
    // "left","right", "bcenter" = Legend location 
    // "label" = 2 before the last entries of histname is the X and Y label otherwise use the default 
    // "log" = Set log scale
    // "leg" = DO NOT draw legend
    // "OBJ" = optional stuff for later? 

    if(hist.size()!=1){
        printf("\n Requires only 1 histogram with errors");
        return;
    }

    gStyle->SetOptStat(0);      // No Stat Box
    gStyle->SetOptTitle(0);     // No Title
    gStyle->SetPadTickX(1);
    gStyle->SetPadTickY(1);
    if(opt.Contains("log")) gStyle->SetOptLogy(1);
    
    TString drawopt = "SAME_P2"; 

    gStyle->SetPalette(1);
    TColor *pal = new TColor();
    // good for primary marker colors                                                                                             

    Int_t kmagenta = pal->GetColor(124,  0,124);
    Int_t kviolet  = pal->GetColor( 72,  0,190);
    Int_t kblue    = pal->GetColor(  9,  0,200);
    Int_t kazure   = pal->GetColor(  0, 48, 97);
    Int_t kcyan    = pal->GetColor(  0, 83, 98);
    Int_t kteal    = pal->GetColor(  0, 92, 46);
    Int_t kgreen   = pal->GetColor( 15, 85, 15);
    Int_t kspring  = pal->GetColor( 75, 97, 53);
    Int_t kyellow  = pal->GetColor(117,118,  0);
    Int_t korange  = pal->GetColor(101, 42,  0);
    Int_t kred     = pal->GetColor(190,  0,  3);
    Int_t kpink    = pal->GetColor(180, 35,145);

    Int_t kmagentaLight = pal->GetColor(215,165,215);
    Int_t kvioletLight  = pal->GetColor(200,160,255);
    Int_t kblueLight    = pal->GetColor(178,185,254);
    Int_t kazureLight   = pal->GetColor(153,195,225);
    Int_t kcyanLight    = pal->GetColor(140,209,224);
    Int_t ktealLight    = pal->GetColor( 92,217,141);
    Int_t kgreenLight   = pal->GetColor(135,222,135);
    Int_t kspringLight  = pal->GetColor(151,207,116);
    Int_t kyellowLight  = pal->GetColor(225,225,100);
    Int_t korangeLight  = pal->GetColor(255,168,104);
    Int_t kredLight     = pal->GetColor(253,169,179);
    Int_t kpinkLight    = pal->GetColor(255,192,224);
    const std::vector<int> colarray  = {9,kmagenta,kgreen,kviolet,kazure,korange,kcyan,kteal,kspring,kpink,kyellow,kmagenta,kviolet,kblue}; // 2
    const std::vector<int> markarray = {25, 22, 32, 29, 28, 39, 40,
                                        24, 21, 26, 23, 30, 34, 37, 41};

    // TCanvas c;
    c.cd();

    float leg_x1 = 0.7;
    float leg_y1 = 0.7;
    float leg_x2 = 0.8;
    float leg_y2 = 0.85;
    if(opt.Contains("bcenter")){
        leg_x1 = 0.45;
        leg_y1 = 0.15;
        leg_x2 = 0.55;
        leg_y2 = 0.3;
    }
    else if(opt.Contains("left")){
        leg_x1 = 0.15;
        leg_y1 = 0.7;
        leg_x2 = 0.25;
        leg_y2 = 0.85;
    }
    l1 = new TLegend(leg_x1, leg_y1, leg_x2, leg_y2,"","brNDC");
    l1->SetFillStyle(0);
    l1->SetFillColor(0);
    l1->SetLineColor(0);
    l1->SetTextSize(0.025);
    l1->SetTextFont(42);

    hist[0]->SetLineColor(1);
    hist[0]->SetMarkerColor(1);
    hist[0]->SetMarkerStyle(20);
    // hist[0]->SetMarkerSize(0.2);
    hist[0]->Draw("][HIST_P0_E1");
    hist[0]->GetXaxis()->SetRange(1,hist[0]->GetNbinsX()-1);
    l1->AddEntry(hist[0],"Data","lep");

    for(std::size_t ihist=0; ihist<err_graph.size();ihist++){
        err_graph[ihist]->SetFillStyle(3001);
        err_graph[ihist]->SetFillColorAlpha(colarray[ihist],(ihist%2)?0.8:0.1);
        err_graph[ihist]->SetLineColor(colarray[ihist]);
        err_graph[ihist]->SetMarkerColor(colarray[ihist]);
        err_graph[ihist]->SetMarkerSize(0);
        
        if(opt.Contains("flow"))
            err_graph[ihist]->GetXaxis()->SetRange(0,hist[ihist]->GetNbinsX()+2);
        err_graph[ihist]->Draw(drawopt);      
        // err_graph[ihist]->Draw((ihist==0)?"A"+drawopt:drawopt); 
        l1->AddEntry(err_graph[ihist], histname[ihist], "f");
    }
    hist[0]->Draw("SAME][HIST_P0_E1");
    if(opt.Contains("label")){
        hist[0]->GetXaxis()->SetTitle(histname.at(histname.size()-3));
        hist[0]->GetYaxis()->SetTitle(histname.at(histname.size()-2));
    }
    else{
        hist[0]->GetXaxis()->SetTitle(hist[0]->GetXaxis()->GetTitle());
        hist[0]->GetYaxis()->SetTitle(hist[0]->GetYaxis()->GetTitle());
    }
    if(!opt.Contains("leg"))
        l1->Draw();


    TLatex latex;
    latex.SetTextSize(0.035);
    if(label.Contains("Data"))
        latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary}} #bf{PbPb 1.7 nb^{-1}(5.02 TeV)}");
    else
        latex.DrawLatexNDC(0.1,0.92,"CMS #it{#bf{Preliminary Simulation}}");

    if(eopt[0].Contains("Cent")){
        latex.DrawLatexNDC(0.78,0.92,eopt[0]);
    }
    else if(eopt.size()>=2){
        latex.DrawLatexNDC(0.41,0.92,eopt[0]);
        latex.DrawLatexNDC(0.78,0.92,eopt[1]);
    }    
    latex.SetTextSize(0.025);
    if(eopt.size()>2){
        for(std::size_t ind=2;ind<eopt.size() && !eopt[ind].Contains("end"); ind++){
            if(opt.Contains("bcenter")){
                leg_y2+=0.05;
                latex.DrawLatexNDC(leg_x1,leg_y2,eopt[ind]);
            }
            else{
                leg_y1-=0.05;
                latex.DrawLatexNDC(leg_x1,leg_y1,eopt[ind]);
            }
        }
    }
    gPad->Update();
    c.SaveAs(output_path +histname.back()+".png");
    c.SaveAs(output_path +histname.back()+".C");
    c.Write(histname.back()+"_canv",TObject::kWriteDelete);
    c.Draw();
    std::cout<<histname.back()<<" has been saved"<<std::endl;
    // delete l;
    if(opt.Contains("log")) gStyle->SetOptLogy(0);
    return c;
}
